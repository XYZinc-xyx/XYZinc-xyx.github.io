[{"title":"关于文章图片不显示的问题","url":"/2022/05/31/%E5%85%B3%E4%BA%8E%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/","content":"<p>众所周知，科学是第一生产力，只有懂得用科学的方式上网，才能对知识有更多的领悟。</p>\n","categories":["test"],"tags":["test"]},{"title":"二分","url":"/2022/08/22/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/","content":"<h1 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h1><p>二分思想在解决算法问题中通常用于<strong>二分查找</strong>和<strong>二分答案</strong></p>\n<h2 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><p>二分思想：在有序序列a[l, r]中查找一个数，可以每次取序列的中间数a[mid = (l + r)/2]与其比较，若待查找数小于中间数，则表示其在序列[l, mid - 1]中；若待查找数大于中间数，则表示其在序列[mid + 1, r]中。重复上述过程继续查找，直至a[mid]为待查找数。</p>\n<p>在一个有序序列中使用二分查找的复杂度为O(logn)</p>\n<h2 id=\"二分答案\"><a href=\"#二分答案\" class=\"headerlink\" title=\"二分答案\"></a>二分答案</h2><p>将二分查找的思想推广，对于一个具有单调性的问题，我们可以通过二分的策略找到最优的答案。</p>\n<p>在二分查找过程中，对于每次比对的数，若待查找的数更小，则挪动边界在较小区间继续查找；若带查找的数更大，则挪动边界在较大区间查找。</p>\n<p>推广至二分答案，则是在一个区间内二分地枚举答案，判定其是否满足题目条件。如果满足，则去寻找更好的解；如果不满足，则去尝试一些更劣的解，判断其是否能满足。</p>\n<p>一个常见说法是：“求最大的最小”，“最小的最大”</p>\n<h1 id=\"二分的边界问题\"><a href=\"#二分的边界问题\" class=\"headerlink\" title=\"二分的边界问题\"></a>二分的边界问题</h1><h2 id=\"手写二分\"><a href=\"#手写二分\" class=\"headerlink\" title=\"手写二分\"></a>手写二分</h2><p>二分是一个思想比较简单的基本算法，但却容易被错误的实现，其中，最常出错的地方即为二分的边界问题。</p>\n<p>这里介绍一种比较通用的写法，可以应对绝大多数的二分问题。以二分查找为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = n;    <span class=\"comment\">// 设置查找的边界</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;        <span class=\"comment\">// ans记录查找的答案</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (left &lt;= right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (left + right) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr[mid] &lt;= key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        ans = mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h2><p>algorithm头文件下有三个二分查找函数，分别为binary_search，lower_bound和upper_bound。要求序列必须有序</p>\n<ol>\n<li><p>binary_search()</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找[first, last]区域内是否包含val。返回true/false分别代表val存在/不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">binary_search</span> <span class=\"params\">(ForwardIterator first, ForwardIterator last, <span class=\"keyword\">const</span> T&amp; val)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">binary_search</span> <span class=\"params\">(ForwardIterator first, ForwardIterator last, <span class=\"keyword\">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lower_bound()</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找[first, last]区域内第一个大于等于val数。返回一个正向迭代器，若存在这样的数，迭代器指向找到的数；若不存在，迭代器指向和last迭代器指向相同</span></span><br><span class=\"line\"><span class=\"function\">ForwardIterator <span class=\"title\">lower_bound</span> <span class=\"params\">(ForwardIterator first, ForwardIterator last, <span class=\"keyword\">const</span> T&amp; val)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ForwardIterator <span class=\"title\">lower_bound</span> <span class=\"params\">(ForwardIterator first, ForwardIterator last, <span class=\"keyword\">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>upper_bound()</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找[first, last]区域内第一个大于val数。返回一个正向迭代器，若存在这样的数，迭代器指向找到的数；若不存在，迭代器指向和last迭代器指向相同</span></span><br><span class=\"line\"><span class=\"function\">ForwardIterator <span class=\"title\">upper_bound</span> <span class=\"params\">(ForwardIterator first, ForwardIterator last, <span class=\"keyword\">const</span> T&amp; val)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ForwardIterator <span class=\"title\">upper_bound</span> <span class=\"params\">(ForwardIterator first, ForwardIterator last, <span class=\"keyword\">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":["算法"],"tags":["二分"]},{"title":"C++秋招整理","url":"/2022/08/22/C++%E7%A7%8B%E6%8B%9B%E6%95%B4%E7%90%86/","content":"<h1 id=\"C-突击面试\"><a href=\"#C-突击面试\" class=\"headerlink\" title=\"C++突击面试\"></a>C++突击面试</h1><p>参考博客：<a href=\"https://blog.csdn.net/luanfenlian0992/article/details/120022236?spm=1001.2014.3001.5502\">https://blog.csdn.net/luanfenlian0992/article/details/120022236?spm=1001.2014.3001.5502</a></p>\n<h2 id=\"编译内存相关\"><a href=\"#编译内存相关\" class=\"headerlink\" title=\"编译内存相关\"></a>编译内存相关</h2><ol>\n<li><p>C++程序编译过程</p>\n<p> 编译过程分为四个部分：编译预处理，编译，汇编，链接</p>\n<ul>\n<li><p>编译预处理：主要处理#开头的指令。例如#include的头文件要导入，#define的宏要展开，处理条件预编译指令等，删除注释</p>\n</li>\n<li><p>编译：编译阶段编译器主要做词法分析、语法分析、语义分析等，检查无误后将源码翻译成汇编语言</p>\n</li>\n<li><p>汇编：将汇编代码翻译成机器语言，生成二进制文本形式的.o文件</p>\n</li>\n<li><p>链接：编译时编译器只对单个文件进行了处理，而某个源文件中的函数可能引用了另一个源文件中定义的某个符号，或者调用了某个库文件中的函数，这时是无法确定它的地址的，只有将所有目标文件链接到一起才能确定最终的地址。链接的目的就是将目标文件</p>\n<ul>\n<li><p>静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中</p>\n<ul>\n<li><p>浪费空间：每个可执行文件都会有目标文件的一个副本，如果目标文件进行了修改，就需要重新编译链接生成新的可执行文件（更新困难）</p>\n</li>\n<li><p>运行速度快，因为可执行程序具备了程序运行的所有内容</p>\n</li>\n</ul>\n</li>\n<li><p>动态链接：</p>\n<ul>\n<li><p>节省内存，更新方便</p>\n</li>\n<li><p>每次运行都需要链接，相比静态链接会有一定的性能损失</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>C++内存管理</p>\n<p> C++内存分区：栈、堆、全局/静态存储区、常量存储区、代码区</p>\n<ul>\n<li><p><strong>栈</strong>：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放</p>\n</li>\n<li><p><strong>堆</strong>：动态申请的内存空间，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。堆从低地址向高地址增长，一般可以分配几个G大小的内存</p>\n</li>\n<li><p><strong>全局/静态存储区</strong>：存放全局变量和静态变量，程序运行结束操作系统自动释放。<em>C中未初始化的变量存放在.bss段中，初始化的放在.data段中；c++不再区分</em></p>\n</li>\n<li><p><strong>常量存储区</strong>：存放常量，不允许修改，程序运行结束自动释放</p>\n</li>\n<li><p><strong>代码区</strong>：存放函数的二进制代码，由操作系统进行管理</p>\n</li>\n</ul>\n</li>\n<li><p>栈和堆的区别</p>\n<ul>\n<li><p>申请方式：栈是系统自动分配，堆是程序员主动申请</p>\n</li>\n<li><p>申请后系统响应：</p>\n<ul>\n<li><p>分配栈空间时，如果剩余空间大于申请空间则分配成功，否则分配失败，栈溢出</p>\n</li>\n<li><p>堆在内存中的呈现方式类似于链表（记录空闲地址空间的链表），申请空间时，会遍历链表，找到第一个大于申请空间的节点分配给程序，并将该节点从链表中删除。对于大多数系统，会在这块内存空间的首地址处记录本次分配空间的大小，便于释放内存。同时，当内存空间大小大于申请空间大小时，系统会自动将多余的部分重新放入空闲链表中</p>\n</li>\n</ul>\n</li>\n<li><p>空间大小：栈是一块连续的内存区域，大小是操作系统预定好的；堆是不连续的内存区域，大小受限于虚拟内存大小</p>\n</li>\n<li><p>生长方向：栈向低地址扩展；堆向高地址扩展  </p>\n</li>\n<li><p>申请效率：栈由操作系统自动分配，有专门的寄存器存放栈的地址，和专门的指令执行压栈出栈，申请效率高，但不够灵活；堆由程序员主动申请，效率低，使用方便但容易产生碎片</p>\n</li>\n<li><p>存放内容：栈存放函数的局部变量、函数参数、返回地址等；堆存放的内容由程序员填充</p>\n</li>\n</ul>\n</li>\n<li><p>变量的区别</p>\n<p> 全局变量、局部变量、静态全局变量、局部全局变量的区别：</p>\n<ul>\n<li><p>从作用域看：</p>\n<ul>\n<li><p>全局变量：具有全局作用域。只需要在一个源文件中定义，就可以作用于所有的源文件</p>\n</li>\n<li><p>静态全局变量：具有文件作用域。与全局变量的区别在于：如果程序包含多个文件，它作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。故不同源文件中定义相同名字的静态全局变量，也为不同的变量</p>\n</li>\n<li><p>局部变量：具有局部作用域。在程序运行期间不是一直存在，只在函数执行期间存在。函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回</p>\n</li>\n<li><p>静态局部变量：具有局部作用域。只被初始化一次，从被初始化到函数运行结束一致存在，和全局变量的区别在于全局变量对所有的函数都可见，而静态局部变量只对定义自己的函数体可见</p>\n</li>\n</ul>\n</li>\n<li><p>从分配内存空间看：</p>\n<ul>\n<li><p>静态存储区：全局变量，静态局部变量，静态全局变量</p>\n</li>\n<li><p>栈：局部变量</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>全局变量定义在头文件中的问题</p>\n<p> 如果在头文件中定义全局变量，当该头文件被多个文件include时，该变量会被定义多次，导致重复定义，因此不能在头文件中定义全局变量</p>\n</li>\n<li><p>内存对齐</p>\n<ul>\n<li><p>什么是内存对齐</p>\n<p>  内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中</p>\n</li>\n<li><p>内存对齐的原则：</p>\n<ol>\n<li><p>数据成员对齐：结构体的第一个数据成员存放在与结构体偏移量为0的地址处，之后的数据成员存储起始位置都是该数据成员大小的整数倍位置</p>\n</li>\n<li><p>结构体作为数据成员的对齐：如果结构体中还包含结构体成员，内部结构体应该以它的最大数据成员大小的整数倍开始存储。例如：struct A中包含struct B，B的成员有cha, int, double，则B应该以sizeof(double)的整数倍为存储的起始地址</p>\n</li>\n<li><p>整个结构体的大小，应该为其最大数据成员大小的整数倍</p>\n</li>\n</ol>\n</li>\n<li><p>内存对齐的原因</p>\n<ol>\n<li><p>平台原因：某些硬件平台只能存取对齐数据，存取非对齐的数据可能会引发异常</p>\n</li>\n<li><p>性能原因：CPU将内存分成一块一块，块的大小可以是2, 4, 6, 8, 16字节，CPU读取内存时也是一块一块进行读取的。内存对齐后，CPU的内存访问速度回大大提升</p>\n</li>\n</ol>\n</li>\n<li><p>内存对齐的优点</p>\n<ol>\n<li><p>便于在不同平台之间进行移植</p>\n</li>\n<li><p>提高内存的访问效率</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>内存泄漏</p>\n<ul>\n<li><p>什么是内存泄漏</p>\n<p>  内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存</p>\n</li>\n<li><p>内存泄漏的常见原因</p>\n<ol>\n<li><p>malloc/new申请的内存没有主动释放</p>\n</li>\n<li><p>malloc/free和new/delete必须各自成对出现，混用可能会造成问题</p>\n</li>\n<li><p>基类的析构函数没有定义为虚函数：当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放</p>\n</li>\n</ol>\n</li>\n<li><p>如何避免内存泄漏</p>\n<ol>\n<li><p>malloc/free和new/delete成对出现</p>\n</li>\n<li><p>智能指针</p>\n</li>\n<li><p>内存泄漏检测工具（？）</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>智能指针</p>\n<ul>\n<li><p>智能指针的用途</p>\n<p>  在C++中，动态内存的管理是用一对运算符完成的：new：在动态内存中为对象分配一块空间并返回一个指向该对象的指针/delete：销毁对象，并释放与之相关的内存</p>\n<p>  动态内存管理时容易出现两种问题：1. 忘记释放内存，造成内存泄漏；2. 尚未有指针引用内存的情况下就释放，会产生引用非法内存的指针。为了更加安全的使用动态内存，引入了智能指针的概念</p>\n</li>\n<li><p>智能指针类型</p>\n<p>  C++11支持三种智能指针，都定义在<code>&lt;memory&gt;</code>头文件中</p>\n<ul>\n<li><p>unique_ptr（独占指针）</p>\n<p>  独享所有权得智能指针，某一时刻只能有一个unique_ptr指向它管理得动态内存上的对象。当unique_ptr销毁的时候，它所指向的对象也会被销毁。</p>\n<ul>\n<li>不能拷贝(copy)和赋值（防止两个指针指向同一个对象），可以通过move()将对象的所有权从一个独占指针转移到另一个独占指针</li>\n</ul>\n</li>\n<li><p>shared_ptr（共享指针）</p>\n<p>  资源可以被多个指针共享。它使用技术机制来表明资源被几个指针共享，可以通过use_count()查看资源的所有者个数。</p>\n<ul>\n<li><strong>shared_ptr的缺点</strong>：<strong>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用</strong>，使引用计数失效，从而导致内存泄漏，此时需要使用weak_ptr</li>\n</ul>\n</li>\n<li><p>weak_ptr（弱指针）</p>\n<p>  weak_ptr用于解决shared_ptr相互引用时的死锁问题：两个shared_ptr相互引用，那么他们的引用计数永远不为0，资源永远不会释放；<strong>weak_ptr是对对象的一种弱引用，不会增加对象的引用计数</strong>。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>智能指针常见问题</p>\n<ul>\n<li><p>一个unique_ptr怎么赋值给另一个unique_ptr</p>\n<p>  借助std::move()</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">ptr1</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;hello world&quot;</span>))</span></span>;</span><br><span class=\"line\">unique_ptr&lt;string&gt; ptr2 = <span class=\"built_in\">move</span>(ptr1);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用智能指针可能出现的问题</p>\n<p>  shared_ptr循环引用（应该被调用的析构函数没有被调用，从而出现了内存泄漏）</p>\n<ul>\n<li>解决方法：weak_ptr</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>深拷贝与浅拷贝</p>\n<ul>\n<li><p>C++<strong>默认</strong>的拷贝构造函数是<strong>浅拷贝</strong></p>\n<p>  它只会复制一个一模一样的指针，并不会操作指针指向的东西，想要实现特定的逻辑需求，就要自定义拷贝构造函数，实现深拷贝</p>\n</li>\n<li><p>浅拷贝：将原对象或数组的引用直接赋给新对象/数组，新对象/数组只是原对象的一个引用</p>\n</li>\n<li><p>深拷贝：创建一个新的对象/数组，将原对象各项属性的值拷贝过去</p>\n</li>\n<li><p>引用拷贝/浅拷贝/深拷贝 区别：</p>\n<ul>\n<li><p>引用拷贝只是复制对象的地址，不会创建新的对象，任一变量修改都会引起其他变量修改；</p>\n</li>\n<li><p>浅拷贝会创建一个新对象，进行属性复制，但对于引用类型的属性，只会复制其对象地址，依然存在引用拷贝的连带修改问题</p>\n</li>\n<li><p>深拷贝完全复制整个对象，包括引用类型的属性。（深拷贝会在堆内存中另外申请空间来存储数据，而不是一个简单的赋值过程）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"语言对比\"><a href=\"#语言对比\" class=\"headerlink\" title=\"语言对比\"></a>语言对比</h2><ol>\n<li><p>C++11新特性</p>\n<ul>\n<li><p>auto类型推导</p>\n<p>  自动类型推导，编译器会在<strong>编译期间</strong>通过初始值推导出变量的类型，auto定义的变量必须有初值</p>\n</li>\n<li><p>decltype类型推导</p>\n<p>  “declare type”的缩写，译为“声明类型”。和auto功能一样，用于<strong>在编译时期进行自动类型推导</strong></p>\n<p>  decltype可以从表达式的类型推断出要定义的变量类型，但不使用该表达式的值初始化变量</p>\n</li>\n<li><p>lambda表达式/lambda函数/匿名函数</p>\n<p>  用于定义并创建匿名的函数对象</p>\n<ul>\n<li><p>lambda语法形式</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[OuterVar](<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y) -&gt; <span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OuterVar + x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [OuterVar]：括号内为捕获变量或者为空</span></span><br><span class=\"line\"><span class=\"comment\">// (int x, int y): 括号内为参数列表</span></span><br><span class=\"line\"><span class=\"comment\">// -&gt; : 箭头指向返回类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;&#125; : 括号内为函数主体</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>eg.</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) -&gt; <span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">f</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译器可以自行推导返回值，故与以下代码等价</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> f = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">f</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>变量捕获 Capture Clause</p>\n<p>  功能：让匿名函数可以访问，甚至修改外部的变量</p>\n<p>  [N, &amp;M]: 变量名前有引用符号，按引用捕获，可以修改变量的值；不加引用符号是按值捕获，只能访问不能修改 </p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> N = <span class=\"number\">100</span>, M = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> g = [N, &amp;M](<span class=\"keyword\">int</span> i) &#123;</span><br><span class=\"line\">    M = <span class=\"number\">20</span>; </span><br><span class=\"line\">    <span class=\"comment\">// N = 30; 不能修改N，会报错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> N * i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">g</span>(<span class=\"number\">10</span>) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; M &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>[&amp;]：捕获语句中只写引用符号，会按照引用捕获所有的封闭范围中的变量</p>\n</li>\n<li><p>[=]：捕获语句中只写等号，所有的变量按值捕获</p>\n</li>\n<li><p>[&amp;, =N]：单独指定一些变量按值捕获，其余变量按引用捕获。例如：按值捕获N</p>\n<ul>\n<li><p>引用捕获N，按值捕获M的写法：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[&amp;N, M]</span><br><span class=\"line\">[M, &amp;N]</span><br><span class=\"line\">[&amp;, =M]</span><br><span class=\"line\">[=, &amp;N]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>[this]：在class中使用匿名函数，可以用this捕获当前实例的指针</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>范围for语句</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (declaration : expression) &#123;</span><br><span class=\"line\">    statement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// expression</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>右值引用</p>\n<p>  绑定到右值的引用，用&amp;&amp;来获得右值引用。右值引用智能绑定到要销毁的对象上</p>\n<p>  引入右值引用的原因：替代要销毁对象的拷贝，提高效率；移动含有不能共享资源的类对象</p>\n<blockquote>\n<p>左值：在内存有确定存储地址、变量名，表达式结束依然存在的值</p>\n<p>右值：在内存中没有确定存储地址、没有变量名，表达式结束就会销毁的值</p>\n</blockquote>\n</li>\n<li><p>智能指针</p>\n</li>\n<li><p>delete函数和default函数</p>\n</li>\n</ul>\n</li>\n<li><p>C和C++的区别  </p>\n<ul>\n<li><p>C是过程式编程语言，不支持类和对象，不支持多态、封装和继承；C++是过程式和面向对象编程语言的结合，支持多态、封装和继承</p>\n<ul>\n<li><p>面向过程的思路：分析解决问题所需的步骤，用函数把这些步骤依次实现</p>\n</li>\n<li><p>面向对象的思路：把构成问题分解为各个对象，建立对象的目的不是完成一个步骤，而是描述某个事物在解决整个问题步骤中的行为</p>\n</li>\n<li><p>优缺点：</p>\n<ul>\n<li><p>面向过程语言：性能较高，适用于单片机、嵌入式开发、Linux/Unix等；没有面向对象易维护、易复用、易扩展</p>\n</li>\n<li><p>面向对象语言：易维护、易复用、易扩展，因为具有封装、继承、多态的特性，可以设计出低耦合的系统，使其更加灵活、易于维护；但性能比面向过程低</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>动态内存管理：C通过malloc/free进行内存的分配和释放；C++通过new/delete管理内存</p>\n</li>\n<li><p>C和C++相比，可以说C是C++的子集，C++是C的超集。C++可以运行大部分C代码，C不能运行C++代码</p>\n</li>\n<li><p>C++支持namespace命名空间，可以让用户自定义心得名字空间作用域，避免全局的名字冲突；C不支持</p>\n</li>\n</ul>\n</li>\n<li><p>Python和C++的区别</p>\n<ul>\n<li><p>语言：Python为脚本语言，解释执行，不需要经过编译；C++是一种需要编译后才能运行的语言，在特定的机器上编译后运行</p>\n</li>\n<li><p>运行效率：C++运行效率高，安全稳定。</p>\n<p>  Python和C++代码最终都会转化为CPU指令，但一般情况下，Python转换出的CPU指令会比C++多很多；其次，Python是解释执行的，和物理机CPU之间多了解释器，C++编译执行，直接就是机器编码，编译的时候编译器还会进行优化。</p>\n</li>\n<li><p>开发效率：Python开发效率高，一两句代码就能实现的功能，C++往往需要更多的代码才能实现</p>\n</li>\n<li><p>语法：Python不需要声明就能使用，语法更加灵活，更适用于上层开发者</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><ol>\n<li><p>面向对象的三大特性</p>\n<p> 面向对象：面向对象把数据和对数据的操作方法放在一起，作为一个相互依存的整体，即对象。</p>\n<p> 面向对象的三大特性：</p>\n<ul>\n<li><p>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。增强了数据安全性以及隐藏了类的实现细节，使用者无需了解具体实现细节</p>\n</li>\n<li><p>继承：子类继承父类的特征和行为，子类有父类的非private方法和变量成员，子类可以对父类的方法进行重写，减少代码冗余、提高代码复用性，便于功能的扩展</p>\n</li>\n<li><p>多态：多态是不同继承类的对象，对同一消息做出不同的相应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式</p>\n</li>\n</ul>\n</li>\n<li><p>重载、重写、隐藏的区别</p>\n<ul>\n<li><p>重载：重载指在同一访问区内声明多个具有不同参数列表（参数类型、个数、顺序）的同名函数</p>\n</li>\n<li><p>重写（覆盖）：派生类中存在重新定义的函数，函数名和参数列表与基函数相同，函数体不同。派生调用时会调用派生类的重写函数，相当于将原函数覆盖掉。重写的基类中被重写的函数必须有virtual修饰</p>\n</li>\n<li><p>隐藏：当派生类中存在与基类同名的函数，不论参数列表是否相同，基类函数都会被隐藏。调用时访问的是派生类的函数。</p>\n</li>\n<li><p><strong>重写</strong>与<strong>重载</strong>的区别</p>\n<ul>\n<li><p>范围区别：重载发生在同一个类的内部，重写发生在不同类之间（父类和子类）</p>\n</li>\n<li><p>参数区别：重写与重载的函数名都与原函数相同，重写要求参数列表和返回值也相同，重写函数会将原函数覆盖；重载要求不相同的参数列表，不关注返回值，调用时根据传入参数类型匹配调用的具体时哪一个函数</p>\n</li>\n<li><p>virtual：重写的函数基类中必须有virtual关键字的修饰，重载的函数可以有也可以没有</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"类相关\"><a href=\"#类相关\" class=\"headerlink\" title=\"类相关\"></a>类相关</h2><h2 id=\"关键字库函数\"><a href=\"#关键字库函数\" class=\"headerlink\" title=\"关键字库函数\"></a>关键字库函数</h2><h2 id=\"语言特性相关\"><a href=\"#语言特性相关\" class=\"headerlink\" title=\"语言特性相关\"></a>语言特性相关</h2>","categories":["笔记"],"tags":["C++"]},{"title":"计网秋招整理","url":"/2022/08/16/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"协议层次以及它们的服务类型\"><a href=\"#协议层次以及它们的服务类型\" class=\"headerlink\" title=\"协议层次以及它们的服务类型\"></a>协议层次以及它们的服务类型</h1><h2 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202208162222219.png\" width=\"400\"></p>\n<ol>\n<li><p>应用层</p>\n<p> 应用层的作用是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互规则。</p>\n<p> 常见的应用层协议有：域名系统DNS，支持万维网应用的HTTP协议，电子邮件系统采用的SMTP协议。在应用层交互的数据单位称之为报文</p>\n</li>\n<li><p>表示层</p>\n<p> 表示层的作用是使通信的应用程序能够解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述，确保一个系统应用层所发送的信息可以被另一个系统的应用层读取</p>\n</li>\n<li><p>会话层</p>\n<p> 会话层负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案的方法</p>\n</li>\n<li><p>传输层</p>\n<p> 传输层主要负责向两台主机<strong>进程</strong>之间的通信提供数据传输服务。应用程序利用该服务传送应用层报文</p>\n<p> 传输层主要使用以下两种协议：传输控制协议TCP(Transmission Control Protocol)：提供面向连接的、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP(User Datagram Protocol)：提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提供完整性服务，UDP主要提供及时性服务</p>\n</li>\n<li><p>网络层</p>\n<p> 在计算机网络中进行通信的两个计算机之间可能会经过多个数据链路，甚至可能经过很多通信子网。网络层的任务就是选择合适的网间路由器和交换节点，确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。</p>\n<blockquote>\n<p>网络层为<strong>主机</strong>提供数据传输服务，传输层为<strong>主机中的进程</strong>提供数据传输服务</p>\n</blockquote>\n<p> 常见的网络层协议有：网际互联协议IP(Internet Protocol)，Internet控制报文协议ICMP(Internet Control Message Protocol)，ICMPv6,等</p>\n</li>\n<li><p>数据链路层</p>\n<p> 两台主机之间的数据传输，总是在一段一段的链路上传送的，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧，在两个相邻节点间的链路上传送。</p>\n<p> 数据链路层的主要功能是：在物理层提供的比特流的基础上，通过差错控制、流量控制方法、使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p>\n</li>\n<li><p>物理层</p>\n<p> 物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必考虑网络的具体传输介质是什么。</p>\n<p> 物理层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性、过程特性等）</p>\n</li>\n</ol>\n<h2 id=\"TCP-IP参考模型\"><a href=\"#TCP-IP参考模型\" class=\"headerlink\" title=\"TCP/IP参考模型\"></a>TCP/IP参考模型</h2><pre><code>OSI七层模型基于标准化考虑，而没有考虑具体的市场需求，使得模型结构复杂，部分功能冗余，因而完全实现OSI参考模型的系统不多。\n\nTCP/IP模型将协议分成四个层次，直接面向市场需求，实现较容易。\n</code></pre><ol>\n<li><p>应用层</p>\n<p> TCP/IP模型将OSI参考模型中的应用层、表示层和会话层的功能合并到一个应用层实现，通过不同的协议为不同的应用提供服务。如：FTP、Telnet、DNS、SMTP等</p>\n</li>\n<li><p>传输层</p>\n<p> 该层对应OSI参考模型中的传输层，为上层实体提供源端到对端主机的通信功能。</p>\n<p> 传输层定义了两个主要协议：TCP和UDP。面向连接的TCP协议保证了数据的传输可靠性，面向无连接的UDP协议能够实现数据报简单、快速地传输。</p>\n</li>\n<li><p>网际互联层</p>\n<p> 该层对应OSI参考模型中的网络层，主要负责相同或不同网络中计算机之间的通信。</p>\n<p> 在网际互联层，IP协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。将数据传送到数据报报头中的目的地址，在这个过程中IP负责选择和传送路线。除IP协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）</p>\n</li>\n<li><p>网络接入层</p>\n<p> 该层对应OSI参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。</p>\n<p> 事实上，TCP/IP本身并未定义该层的协议，而由参与互联的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异</p>\n</li>\n</ol>\n<h2 id=\"TCP-IP五层参考模型\"><a href=\"#TCP-IP五层参考模型\" class=\"headerlink\" title=\"TCP/IP五层参考模型\"></a>TCP/IP五层参考模型</h2><p>TCP/IP五层体系的协议结构是综合了OSI和TCP/IP优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。</p>\n<p>其中应用层对应OSI的上三层（应用层，表示层，会话层），下四层与OSI相同。五层协议的体系结构是为介绍网络原理而设计的，实际应用还是TCP/IP四层体系结构</p>\n<h2 id=\"OSI模型和TCP-IP模型异同比较\"><a href=\"#OSI模型和TCP-IP模型异同比较\" class=\"headerlink\" title=\"OSI模型和TCP/IP模型异同比较\"></a>OSI模型和TCP/IP模型异同比较</h2><ul>\n<li><p>相同点：</p>\n<ol>\n<li><p>OSI参考模型与TCP/IP参考模型都采用了层次结构</p>\n</li>\n<li><p>都能提供面向连接和无连接两种通信服务机制</p>\n</li>\n</ol>\n</li>\n<li><p>不同点：</p>\n<ol>\n<li><p>OSI采用七层模型；TCP/IP是四层结构</p>\n</li>\n<li><p>TCP/IP参考模型没有对网络接口进行细分，只是一些概念性的描述；OSI参考模型对服务和协议做了明确的区分</p>\n</li>\n<li><p>OSI先有模型，后有协议规范，适合于描述各种网络；TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络</p>\n</li>\n<li><p>TCP/IP一开始就提出面向连接和无连接服务，而OSI一开始只强调面向连接服务，直到很晚才开始定制无连接的服务标准</p>\n</li>\n<li><p>OSI模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP/IP参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"OSI和TCP-IP协议之间的对应关系\"><a href=\"#OSI和TCP-IP协议之间的对应关系\" class=\"headerlink\" title=\"OSI和TCP/IP协议之间的对应关系\"></a>OSI和TCP/IP协议之间的对应关系</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>OSI七层网络模型</th>\n<th>TCP/IP四层概念模型</th>\n<th>TCP/IP五层概念模型（参考模型）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用层</td>\n<td>应用层</td>\n<td>应用层</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>应用层</td>\n<td>应用层</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>应用层</td>\n<td>应用层</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>传输层</td>\n<td>传输层</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>网络层</td>\n<td>网络层</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>网络接口层</td>\n<td>数据链路层</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>网络接口层</td>\n<td>物理层</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"为什么TCP-IP去除了表示层和会话层\"><a href=\"#为什么TCP-IP去除了表示层和会话层\" class=\"headerlink\" title=\"为什么TCP/IP去除了表示层和会话层\"></a>为什么TCP/IP去除了表示层和会话层</h2><p>会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间几乎无法实现代码的抽象共享，所以OSI设想中的应用程序维度的分层是难以实现的。所以TCP/IP协议框架的设计中，将会话层、表示层、应用层整合在一起，使整个过程更加清晰明了</p>\n<h2 id=\"数据如何在各层之间传输（数据的封装过程）\"><a href=\"#数据如何在各层之间传输（数据的封装过程）\" class=\"headerlink\" title=\"数据如何在各层之间传输（数据的封装过程）\"></a>数据如何在各层之间传输（数据的封装过程）</h2><p>…</p>\n<h1 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h1><h2 id=\"HTTP头部包含哪些信息\"><a href=\"#HTTP头部包含哪些信息\" class=\"headerlink\" title=\"HTTP头部包含哪些信息\"></a>HTTP头部包含哪些信息</h2><p>超文本传输协议HTTP(HyperText Transfer Protocol)是一种用于分布式、协作式和超媒体信息系统的应用层协议。它是用于从万维网服务器与本地浏览器之间传输超文本的传送协议。</p>\n<h2 id=\"一些网址\"><a href=\"#一些网址\" class=\"headerlink\" title=\"一些网址\"></a>一些网址</h2><p><a href=\"https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_1-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_1-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></p>\n<p><a href=\"https://blog.csdn.net/luanfenlian0992/article/details/120022236?spm=1001.2014.3001.5502\">https://blog.csdn.net/luanfenlian0992/article/details/120022236?spm=1001.2014.3001.5502</a></p>\n<p><a href=\"https://blog.csdn.net/luanfenlian0992/article/details/118916798?spm=1001.2014.3001.5502\">https://blog.csdn.net/luanfenlian0992/article/details/118916798?spm=1001.2014.3001.5502</a></p>\n<p><a href=\"https://blog.csdn.net/luanfenlian0992/article/details/118771472?spm=1001.2014.3001.5502\">https://blog.csdn.net/luanfenlian0992/article/details/118771472?spm=1001.2014.3001.5502</a></p>\n","categories":["笔记"],"tags":["计网"]},{"title":"C++ Primer简单笔记","url":"/2022/07/19/C++%20Primer%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"C-基础\"><a href=\"#C-基础\" class=\"headerlink\" title=\"C++基础\"></a>C++基础</h1><h2 id=\"变量和基本类型\"><a href=\"#变量和基本类型\" class=\"headerlink\" title=\"变量和基本类型\"></a>变量和基本类型</h2><h3 id=\"基本内置类型\"><a href=\"#基本内置类型\" class=\"headerlink\" title=\"基本内置类型\"></a>基本内置类型</h3><ol>\n<li><p>算数类型和空类型</p>\n<p> 算数类型：整型（包括字符和布尔），浮点型</p>\n<p> 带符号和无符号类型（unsigned）</p>\n</li>\n<li><p>类型转换</p>\n<p> 在程序中如果对对象进行了非其类型的使用，程序会自动进行类型转换</p>\n</li>\n<li><p>字面值常量</p>\n<p> 字面值即一个具体的数值，一看便知。每个字面值常量对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>      <span class=\"comment\">// 十进制</span></span><br><span class=\"line\"><span class=\"number\">024</span>     <span class=\"comment\">// 八进制</span></span><br><span class=\"line\"><span class=\"number\">0x14</span>    <span class=\"comment\">// 十六进制</span></span><br><span class=\"line\"><span class=\"comment\">// 默认情况下，十进制字面值是带符号数，类型为int、long和long long中能容纳当前值的尺寸最小的那个；八进制和十六进制字面符既可能是带符号的也可能是无符号的，类型为int、unsigned int、long、unsigned long、long long、unsigned long long中最小的。</span></span><br><span class=\"line\"><span class=\"comment\">// 如果一个字面值连与之关联的最大数据类型都放不下，将产生错误。</span></span><br><span class=\"line\"><span class=\"comment\">// short没有对应的字面符。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.12159</span></span><br><span class=\"line\"><span class=\"number\">3.14159E0</span></span><br><span class=\"line\"><span class=\"number\">0.</span></span><br><span class=\"line\"><span class=\"number\">0e0</span></span><br><span class=\"line\"><span class=\"number\">.001</span>    <span class=\"comment\">// 浮点型字面值，以小数或科学计数法形式表现，指数部分用E或e标识</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;a&#x27;</span>     <span class=\"comment\">// 字符字面值</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello World!&quot;</span>  <span class=\"comment\">// 字符串字面符</span></span><br><span class=\"line\"><span class=\"comment\">// 字符串字面值是由常量字符构成的数组，编译器会在字符串结尾处添家空字符(&#x27;\\0&#x27;)，故&#x27;a&#x27;与“a”是不同的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">false</span>   <span class=\"comment\">// 布尔类型字面值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">nullptr</span> <span class=\"comment\">// 指针类型字面值</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ol>\n<li><p>对象</p>\n<p> 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间</p>\n</li>\n<li><p>初始化</p>\n<p> 初始化和赋值的区别：初始化是创建变量时赋予其一个初始值；赋值则是把对象的当前值擦除，用一个新值来替代</p>\n</li>\n<li><p>变量声明和定义</p>\n<p> C++支持<strong>分离式编译</strong>机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>\n<p> 将声明和定义区分开来，声明使名字为程序所知，定义负责创建于名字关联的实体。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明：在变量名前添加关键字extern，且不要显式初始化变量</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i;   <span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j;          <span class=\"comment\">// 声明并定义</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;   <span class=\"comment\">// 定义，任何包含了显式初始化的声明即成为定义</span></span><br></pre></td></tr></table></figure>\n<p> 函数体内部初始化由extern关键字标记的变量，将引发错误</p>\n</li>\n<li><p>静态类型</p>\n<p> C++是一种静态类型语言（C, Java），其含义是在编译阶段检查类型。定义时声明类型，运行时无法修改，可以确定运行时需要的内存总量，程序复杂时利于类型检查。</p>\n<p> 动态类型语言（python, JavaScript, Ruby），运行阶段检查类型。定义时无需声明类型，运行时可以修改。</p>\n</li>\n<li><p>标识符</p>\n<p> 由字母、数字和下划线组成，必须以字母或下划线开头，长度无限制，大小写敏感。</p>\n<p> C++关键字等一些保留名字不能作为标识符使用，用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。</p>\n</li>\n<li><p>作用域</p>\n<p> 全局作用域，块作用域</p>\n<p> 嵌套作用域：内层可以使用外层作用域的名字，也可以重新定义外层作用域已有的名字。</p>\n</li>\n</ol>\n<h3 id=\"复合类型\"><a href=\"#复合类型\" class=\"headerlink\" title=\"复合类型\"></a>复合类型</h3><ol>\n<li><p>引用</p>\n<p> <strong>引用</strong>为对象起了另外一个名字，引用类型引用另外一种类型。形如&amp;d的形式定义引用类型，d是声明的变量名</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;refVal = ival;     <span class=\"comment\">// refVal指向ival</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;refVal2;           <span class=\"comment\">// 报错，引用必须被初始化</span></span><br></pre></td></tr></table></figure>\n<p> 引用并非对象，只是为一个已存在的对象所起的另外一个名字</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;y = x;</span><br><span class=\"line\">y += <span class=\"number\">3</span>;</span><br><span class=\"line\">cout &lt;&lt; x;      <span class=\"comment\">// 输出8</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> z = y;      <span class=\"comment\">// 相当于z = x</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;w = y;     <span class=\"comment\">// 将w绑定到与y绑定的对象，即x上</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指针</p>\n<p> 指针和引用类似，都实现了对其他对象的间接访问。但指针不同之处在于：1.指针本身也是一个对象，允许对指针进行复制和拷贝；2.指针无需在定义时赋初值。与其他内置类型一样，块作用域内未初始化的指针将拥有一个不确定的值。</p>\n<p> 形如*d的形式定义指针类型，d是变量名。</p>\n<ul>\n<li><p>取地址符 &amp;</p>\n<p>  指针存放某个对象的地址，要想获取该地址，需要使用取址符&amp;</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = &amp;ival;     <span class=\"comment\">// p存放变量ival的地址，或者说p是指向变量ival的指针</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解引用符 *</p>\n<p>  如果指针指向了一个对象，则允许使用解引用符*来访问该对象</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> val = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = &amp;val; </span><br><span class=\"line\">cout &lt;&lt; *p;         <span class=\"comment\">// *p得到p所指的对象，即val</span></span><br></pre></td></tr></table></figure>\n<p>  如果给解引用的结果赋值，实际上就是给指针指向的对象赋值</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">*p = <span class=\"number\">0</span>;             <span class=\"comment\">// val = 0</span></span><br></pre></td></tr></table></figure>\n<p>注意&amp;和*既能用作表达式里的运算符，也能作为声明的一部分出现。注意区分其含义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个特别的例子</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r = *p;            <span class=\"comment\">// &amp;是声明的一部分，*是一个解引用符，将r与*p指向的对象绑定，也即为ival取别名为r</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>空指针</p>\n<p>  空指针不知想任何对象，以下为几种生成空指针的方法</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p1 = <span class=\"literal\">nullptr</span>;      <span class=\"comment\">// 等价于int *p1 = 0;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p2 = <span class=\"number\">0</span>;            <span class=\"comment\">// 直接将p2初始化为字面常量0</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p3 = <span class=\"literal\">NULL</span>;         <span class=\"comment\">// 等价于int *p3 = 0; NULL在头文件cstdlib中定义</span></span><br></pre></td></tr></table></figure>\n<p>  <strong>nullptr与NULL的区别：</strong></p>\n<blockquote>\n<p>nullptr是一个字面值常量，可以转换为任意的指针类型<br>NULL是预处理变量，是一个宏，被定义为空指针。NULL在不同编译器下，可能被定义为0或(void<em>)0，具有二义性，且(void</em>)不允许转换为其他类型，容易产生错误 </p>\n</blockquote>\n</li>\n<li><p>赋值和指针</p>\n<p>  判断一条赋值语句改变的是指针的值还是指针所指对象的值，方法是判断等号左侧的对象究竟是什么</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pi = <span class=\"number\">0</span>;    <span class=\"comment\">// 初始化pi，不指向任何对象</span></span><br><span class=\"line\">pi = &amp;val;      <span class=\"comment\">// pi的值改变，pi现在指向ival</span></span><br><span class=\"line\">*pi = <span class=\"number\">0</span>;        <span class=\"comment\">// *pi的值改变，即pi指向对象val的值改变，即val = 0，指针pi并未改变</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>void* 指针</p>\n<p>  void*是一种特殊的指针类型，可以存放任意对象的地址</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> obj =<span class=\"number\">3.14</span>, *pd = &amp;obj;</span><br><span class=\"line\"><span class=\"keyword\">void</span>* pv = &amp;obj;        <span class=\"comment\">// obj可以是任意类型的对象</span></span><br><span class=\"line\">pv = pd;                <span class=\"comment\">// pv可以存放任意类型的指针</span></span><br></pre></td></tr></table></figure>\n<p>  但需要注意的是，一个void*指针存放的地址究竟是什么我们并不了解，所以不能直接操作其所知的对象。只能和其他指针比较、作为函数的输入输出，或者赋值给另外一个指针。</p>\n</li>\n</ul>\n</li>\n<li><p>复合类型的声明</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">1024</span>, *p = &amp;i, &amp;r = i;</span><br><span class=\"line\"><span class=\"comment\">// i是一个int型变量，p是一个int型指针，r是一个int型引用</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>定义多个变量</p>\n<p>  在定义语句中，类型修饰符（*或&amp;）并不作用于本次定义的全部变量。产生误导的原因是空格可以写在类型修饰符和变量名中间。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* p;         <span class=\"comment\">// 合法，但容易产生误导，最好写作int *p;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p1, p2;    <span class=\"comment\">// *只作用于p1，p1是int类型的指针，p2是int类型的变量</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指向指针的指针</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ival = <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *pi = &amp;ival;    <span class=\"comment\">// pi指向一个int型的数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> **pi = &amp;pi;     <span class=\"comment\">// pi指向一个int型的指针</span></span><br><span class=\"line\">cout &lt;&lt; ival &lt;&lt; *pi &lt;&lt; **pi;    <span class=\"comment\">// 均输出ival</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指向指针的引用</p>\n<p>  引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p;         <span class=\"comment\">// p是一个int型指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *&amp;r = p;    <span class=\"comment\">// r是一个对指针p的引用(&amp;r引用，p是int*类型，所以int *&amp;r)</span></span><br><span class=\"line\"></span><br><span class=\"line\">r = &amp;i;         <span class=\"comment\">// 即 p= &amp;i</span></span><br><span class=\"line\">*r = <span class=\"number\">0</span>;         <span class=\"comment\">// 即*p = 0，解引用p，将p指向的对象i改为0, i = 0</span></span><br></pre></td></tr></table></figure>\n<p>  要判断r的类型，则从右向左阅读r的定义。离变量名最近的符号对变量的类型有最直接的影响，因此上例中r是一个引用。声明符的其余部分用以确定r引用的类型是什么。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"const限定符\"><a href=\"#const限定符\" class=\"headerlink\" title=\"const限定符\"></a>const限定符</h3><p>使用const对变量类型进行修饰，使其变成一个常量。const对象一旦创建后值不能更改，所以const对象必须初始化。</p>\n<p>如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字，再在使用的文件中进行声明。</p>\n<ol>\n<li><p>const的引用</p>\n<p> 对常量的引用和普通引用相似，不同的是，对常量的引用不能被用作修改它所绑定的对象。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r1 = ci; <span class=\"comment\">// 对常量ci进行引用</span></span><br><span class=\"line\">r1 = <span class=\"number\">42</span>;            <span class=\"comment\">// 错误，对常量的引用不能修改它所绑定的对象</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r2 = ci;       <span class=\"comment\">// 错误，非常量引用不能指向一个常量对象</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>常量引用是对const的引用</p>\n</blockquote>\n<ul>\n<li><p>初始化和对const的引用</p>\n<p>  通常情况下，引用的类型必须与所引用对象的类型一致。但在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r1 = i;      <span class=\"comment\">// 允许将const int&amp;绑定到普通的int对象上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r2 = <span class=\"number\">42</span>;     <span class=\"comment\">// 正确，r2是一个常量引用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r3 = r1 * <span class=\"number\">2</span>; <span class=\"comment\">// 正确，r3是一个常量引用</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r4 = r1 * <span class=\"number\">2</span>;       <span class=\"comment\">// 错误，r4是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对const的引用可能引用一个并非const的对象</p>\n<p>  常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r1 = i;</span><br><span class=\"line\"><span class=\"comment\">// r1 = 50;     // 错误</span></span><br><span class=\"line\">i = <span class=\"number\">50</span>;         <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>指针和const</p>\n<p> 指向常量的指针不能用于改变其所指对象的值</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span>;     <span class=\"comment\">// pi是个常量，其值不能修改</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> *ptr = &amp;pi;          <span class=\"comment\">// 错误，ptr是一个普通指针，不能指向一个常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *cptr = &amp;pi;   <span class=\"comment\">// 正确</span></span><br><span class=\"line\">*cptr = <span class=\"number\">42</span>;                 <span class=\"comment\">// 错误，不能通过指向常量的指针改变其所指对象的值</span></span><br></pre></td></tr></table></figure>\n<p> 指向常量的指针也可以修改为指向非常量对象的指针</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 上接上段代码</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.1415</span>; </span><br><span class=\"line\">cptr = &amp;dval;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><p>const指针</p>\n<p>  指针作为对象，允许把其本身设定为常量。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> cur = &amp;num;          <span class=\"comment\">// 从右往左看，cur前缀是const，表示cur是一个常量，*表示cur是一个常量指针，int表示该指针指向一个int对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> pi = <span class=\"number\">3.14</span>;     </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *<span class=\"keyword\">const</span> pip = &amp;pi;  <span class=\"comment\">// 同上，pip是一个常量指针，指向一个双精度浮点型常量</span></span><br></pre></td></tr></table></figure>\n<p>  指针本身是常量意味着它只能指向固定的对象，而不能指向其他的对象。对于其指向对象的值是否能修改，则取决于该对象的类型，与常量指针无关。</p>\n</li>\n</ul>\n<ol>\n<li><p>顶层const</p>\n<p> 如上所述，指针本身是否为常量与指针指向对象是否为常量是两个独立的问题。用<strong>顶层const</strong>表示指针本身是个常量，<strong>底层const</strong>表示指针所指对象是一个常量。</p>\n</li>\n<li><p>constexpr和常量表达式</p>\n<ul>\n<li><p>常量表达式</p>\n<p>  常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> max_files = <span class=\"number\">20</span>;   <span class=\"comment\">// 是常量表达式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> limit = max_files + <span class=\"number\">1</span>;    <span class=\"comment\">// 是常量表达式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sraff_size = <span class=\"number\">27</span>;    <span class=\"comment\">// 不是常量表达式：数据类型只是普通的int</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sz = <span class=\"built_in\">get_size</span>();  <span class=\"comment\">// 不是常量表达式：sz的具体数值需要运行时才能获取</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>constexpr变量</p>\n<p>  C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> mf = <span class=\"number\">20</span>; </span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> limit = mf + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> sz = <span class=\"built_in\">size</span>();  <span class=\"comment\">// 只有当size()是一个constexpr函数时才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指针和constexpr</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> *q = <span class=\"literal\">nullptr</span>;     <span class=\"comment\">// q是一个指向整数的常量指针</span></span><br><span class=\"line\"><span class=\"comment\">// 相当于 int *const q = nullptr;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"处理类型\"><a href=\"#处理类型\" class=\"headerlink\" title=\"处理类型\"></a>处理类型</h3><ol>\n<li><p>类型别名</p>\n<ul>\n<li><p>typedef/using</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span> wages;   <span class=\"comment\">// wages是double的同义词</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> wages base, *p; <span class=\"comment\">// base是double的同义词，p是double*的同义词</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> wages = <span class=\"keyword\">double</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指针、常量和类型别名</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *pstring;  <span class=\"comment\">// pstring是char*的同义词</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pstring cstr = <span class=\"number\">0</span>; <span class=\"comment\">// cstr是指向char的常量指针</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pstring *ps;      <span class=\"comment\">// ps指向的对象是一个指向char的常量指针</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>auto类型说明符</p>\n<p> auto类型说明符让编译器通过初始值来推算变量的类型。auto定义的变量必须有初始值</p>\n<p> 一条声明语句只能有一个基本数据类型，所以使用auto生命多个变量时需保证所有变量的初始基本数据类型一样</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>, *p = &amp;i;    <span class=\"comment\">// 正确，i是整数，p是整型指针</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> sz = <span class=\"number\">5</span>, pi = <span class=\"number\">3.14</span>; <span class=\"comment\">// 错误，sz和pi类型不一致</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>复合类型、常量和auto</p>\n<p>  编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, &amp;r = i;  <span class=\"comment\">// r是对i的引用</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> a = r;         <span class=\"comment\">// 由于r是i的别名，i为整数，所以auto会认为a是一个整数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// auto一般会忽略掉顶层const，保留底层const</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = i, &amp;cr = ci;     <span class=\"comment\">// 整型常量ci，别名cr</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> b = ci;    <span class=\"comment\">// b是一个整数（ci的顶层const特性被忽略）</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> c = cr;    <span class=\"comment\">// c是一个整数（cr是ci的别名）</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> d = &amp;i;    <span class=\"comment\">// d是一个整型指针（&amp;i对整型i取址）</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> e = &amp;ci;   <span class=\"comment\">// e是一个指向整型常量的指针（对常量对象取地址是一种底层const）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果希望推断出的auto类型是一个顶层const，需要明确指出</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> f = ci;  <span class=\"comment\">// f是const int</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>decltype类型指示符</p>\n<p> C++11新标准引入了类型说明符decltype，它可以从表达式的类型推断出要定义的变量的类型，但不使用该表达式的值初始化变量。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(<span class=\"built_in\">f</span>()) sum =  x;     <span class=\"comment\">// sum的类型是函数f的返回类型，值为x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// decltype处理const和引用的方式与auto不同，decltype使用的表达式为变量时，返回该变量的类型（包括顶层const和引用）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = <span class=\"number\">0</span>, &amp;cj = ci; <span class=\"comment\">// 整型常量ci，别名cj</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(ci) x = <span class=\"number\">0</span>;         <span class=\"comment\">// x的类型是const int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(cj) y = x;         <span class=\"comment\">// y是一个const int&amp;引用，绑定到变量x</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(cj) z;             <span class=\"comment\">// 错误，z为引用，必须初始化</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>decltype和引用</p>\n<p>  如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// decltype的结果可以是引用类型</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(r + <span class=\"number\">0</span>) b;      <span class=\"comment\">// 正确，(r+0)结果为int，因此b是一个未初始化的int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(*p) c;         <span class=\"comment\">// 错误，*p的结果为&amp;i，是一个引用，因此c是int&amp;，必须初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，decltype所使用的表达式加不加括号是有区别的</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(i) d;      <span class=\"comment\">// 正确，d的类型为变量i的类型，即一个未初始化的int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>((i)) e;    <span class=\"comment\">// 错误，e的类型为表达式(i)，变量是一种可以作为赋值语句左值的特殊表达式，所以decltype会得到引用类型int&amp;，int&amp;必须初始化</span></span><br></pre></td></tr></table></figure>\n<p>  <strong>decltype((variable))的结果永远是引用，decltype(variable)结果只有当variable本身是一个引用时才是引用</strong></p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"自定义数据结构\"><a href=\"#自定义数据结构\" class=\"headerlink\" title=\"自定义数据结构\"></a>自定义数据结构</h3><ol>\n<li><p>struct结构体定义数据类型</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sales_data</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    std::string bookNo;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> units_sold = <span class=\"number\">0</span>; <span class=\"comment\">// 类内初始值，可以用等号和大括号，不能使用圆括号</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> revenue = &#123;<span class=\"number\">0.0</span>&#125;;</span><br><span class=\"line\">&#125;;<span class=\"comment\">// 注意分号</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用方法</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Sales_data data1, data2;</span><br><span class=\"line\">std::cin &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold &gt;&gt; price;  <span class=\"comment\">// 输入</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写头文件</p>\n<p> 为了确保在各个文件中能使用同一个类，类通常被定义在头文件中，且类的头文件名字应与类的名字一样</p>\n<ul>\n<li><p>头文件保护符</p>\n<p>  预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否己经定义：#ifdef当且仅当变量己定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#end指令为止</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> SALES_DATA_H  <span class=\"comment\">// 第一次包含Sales_data.h时，#ifndef结果为真，执行以下操作直至#endif；再次包含时，将忽略这部分操作</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SALES_DATA_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sales_data</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    std::string boolNo;</span><br><span class=\"line\">    nsigned units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> revenue = &#123;<span class=\"number\">0.0</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"字符串、向量和数组\"><a href=\"#字符串、向量和数组\" class=\"headerlink\" title=\"字符串、向量和数组\"></a>字符串、向量和数组</h2><h3 id=\"命名空间的using声明\"><a href=\"#命名空间的using声明\" class=\"headerlink\" title=\"命名空间的using声明\"></a>命名空间的using声明</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 每个using声明引入命名空间的一个成员</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"comment\">// using namespace std; 引入std命名空间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cin &gt;&gt; x;</span><br><span class=\"line\">    std::cin &gt;&gt; x;  <span class=\"comment\">// 如果没有使用using声明，使用cin时需要从命名空间std中获取它</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"标准库类型string\"><a href=\"#标准库类型string\" class=\"headerlink\" title=\"标准库类型string\"></a>标准库类型string</h3><ol>\n<li><p>定义和初始化string对象</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span>   <span class=\"comment\">// string头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;  <span class=\"comment\">// string定义在命名空间std中</span></span><br><span class=\"line\"></span><br><span class=\"line\">string s1;          <span class=\"comment\">// 默认初始化</span></span><br><span class=\"line\">string s2 = s1;     <span class=\"comment\">// s2是s1的副本</span></span><br><span class=\"line\">string s3 = <span class=\"string\">&quot;hello&quot;</span>;    <span class=\"comment\">// s3是该字符串字面值的副本</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s4</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"string\">&#x27;c&#x27;</span>)</span></span>;     <span class=\"comment\">// s4的内容是ccccccc</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s5</span><span class=\"params\">(s1)</span>           <span class=\"comment\">// 等价于s2</span></span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s6</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>)</span></span>;     <span class=\"comment\">//等价于s3</span></span><br></pre></td></tr></table></figure>\n<p> 使用等号初始化一个变量，执行的是<strong>拷贝初始化</strong>，不使用等号，则执行的是<strong>直接初始化</strong></p>\n</li>\n<li><p>string对象上的操作</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读写string对象</span></span><br><span class=\"line\">string s;</span><br><span class=\"line\">cin &gt;&gt; s;   <span class=\"comment\">// 将string对象读入s，遇到空白停止</span></span><br><span class=\"line\">cout &lt;&lt; s &lt;&lt; endl;  <span class=\"comment\">// 输出s</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读写未知数量的string对象</span></span><br><span class=\"line\">string word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin &gt;&gt; word)  <span class=\"comment\">// 循环读入，直到读到文件结尾</span></span><br><span class=\"line\">    cout &lt;&lt; word &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用getline读取一整行</span></span><br><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin, line); <span class=\"comment\">// getline的参数是一个输入流和一个string对象</span></span><br><span class=\"line\">cout &lt;&lt; line;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// empty和size操作</span></span><br><span class=\"line\">line.<span class=\"built_in\">empty</span>();   <span class=\"comment\">// 根据string对象是否为空返回一个对应的布尔值</span></span><br><span class=\"line\">line.<span class=\"built_in\">size</span>();    <span class=\"comment\">// 返回string对象的长度，返回值类型为string::size_type，是一个无符号型整数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较string对象</span></span><br><span class=\"line\"><span class=\"comment\">// string大小写敏感，且按照字典顺序进行比较</span></span><br><span class=\"line\">string s1 = <span class=\"string\">&quot;abce&quot;</span>;</span><br><span class=\"line\">string s2 = <span class=\"string\">&quot;abcde&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(s1 == s2) cout &lt;&lt; <span class=\"string\">&quot;=&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(s1 != s2) cout &lt;&lt; <span class=\"string\">&quot;!=&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(s1 &gt; s2) cout &lt;&lt; <span class=\"string\">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(s1 &lt; s2) cout &lt;&lt; <span class=\"string\">&quot;&lt;&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(s1 &gt;= s2) cout &lt;&lt; <span class=\"string\">&quot;&gt;=&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(s1 &lt;= s2) cout &lt;&lt; <span class=\"string\">&quot;&lt;=&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两个string相加</span></span><br><span class=\"line\">string s1 = <span class=\"string\">&quot;hello&quot;</span>, s2 = <span class=\"string\">&quot;world\\n&quot;</span>;</span><br><span class=\"line\">string s3 = s1 + s2;</span><br><span class=\"line\">cout &lt;&lt; s3;</span><br><span class=\"line\">s1 += s2;</span><br><span class=\"line\">cout &lt;&lt; s1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// string和字面值相加</span></span><br><span class=\"line\">string s1 = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">string s2 = s1 + <span class=\"string\">&quot; world\\n&quot;</span>;</span><br><span class=\"line\">cout &lt;&lt; s2;</span><br><span class=\"line\">string s3 = <span class=\"string\">&quot;hello&quot;</span> + <span class=\"string\">&quot;world&quot;</span>;  <span class=\"comment\">// 错误，不能把字面值直接相加</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理string对象中的字符</p>\n<ul>\n<li><p>cctype头文件中的函数</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isalnum</span>(c)      <span class=\"comment\">// 当c是字母或数字时为真</span></span><br><span class=\"line\"><span class=\"built_in\">isalpha</span>(c)      <span class=\"comment\">// 当c是字母时为真</span></span><br><span class=\"line\"><span class=\"built_in\">iscntrl</span>(c)      <span class=\"comment\">// 当c是控制字符时为真</span></span><br><span class=\"line\"><span class=\"built_in\">isdigit</span>(c)      <span class=\"comment\">// 当c是数字时为真</span></span><br><span class=\"line\"><span class=\"built_in\">isgraph</span>(c)      <span class=\"comment\">// 当c不是空格但可打印时为真</span></span><br><span class=\"line\"><span class=\"built_in\">islower</span>(c)      <span class=\"comment\">// 当c是小写字母时为真</span></span><br><span class=\"line\"><span class=\"built_in\">isprint</span>(c)      <span class=\"comment\">// 当c是可打印字符时为真（即c是空格或c具有可视形式）</span></span><br><span class=\"line\"><span class=\"built_in\">ispunct</span>(c)      <span class=\"comment\">// 当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空自中的</span></span><br><span class=\"line\"><span class=\"built_in\">isspace</span>(c)      <span class=\"comment\">// 当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）</span></span><br><span class=\"line\"><span class=\"built_in\">isupper</span>(c)      <span class=\"comment\">// 当c是大写字母时为真</span></span><br><span class=\"line\"><span class=\"built_in\">isxdigit</span>(c)     <span class=\"comment\">// 当c是十六进制数字时为真</span></span><br><span class=\"line\"><span class=\"built_in\">tolower</span>(c)      <span class=\"comment\">// 如果c是大写字母，输出对应的小写字母；否则原样输出c</span></span><br><span class=\"line\"><span class=\"built_in\">toupper</span>(c)      <span class=\"comment\">// 如果c是小写字母，输出对应的大写字母：否则原样输出c</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>基于范围的for循环</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (declartion : expression)   <span class=\"comment\">// expression：待访问的对象；declartion：一个变量，用于访问序列中的元素</span></span><br><span class=\"line\">    statement;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;hello world&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c : str)</span><br><span class=\"line\">    cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用范围for语句改变字符串中的字符</p>\n<p>  想要改变string对象中字符的值，必须把循环变量定义成引用类型</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;hello world&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;c : str)</span><br><span class=\"line\">    c = <span class=\"built_in\">toupper</span>(c);</span><br><span class=\"line\">cout &lt;&lt; str;</span><br></pre></td></tr></table></figure>\n<p>访问string对象中的单个字符还可以使用下标和迭代器，要注意下标是否在可访问范围内。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"标准库类型vector\"><a href=\"#标准库类型vector\" class=\"headerlink\" title=\"标准库类型vector\"></a>标准库类型vector</h3><blockquote>\n<p>vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int></int></p>\n</blockquote>\n<ol>\n<li><p>定义和初始化vector对象</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;T&gt; v1;       <span class=\"comment\">// v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v2</span><span class=\"params\">(v1)</span></span>;   <span class=\"comment\">// v2中包含有v1所有元素的副本</span></span><br><span class=\"line\">vector&lt;T&gt; v2 = v1;  <span class=\"comment\">// 等价于v2(v1)</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v3</span><span class=\"params\">(n, val)</span></span>;   <span class=\"comment\">// v3包含了n个重复的元素，每个元素的值都是val</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;T&gt; <span class=\"title\">v4</span><span class=\"params\">(n)</span></span>;    <span class=\"comment\">// v4包含了n执行默认初始化的对象</span></span><br><span class=\"line\">vector&lt;T&gt; v5&#123;a, b, c...&#125;    <span class=\"comment\">// v5包含了初始值个数的元素，每个元素被赋予相应的初始值</span></span><br><span class=\"line\">vector&lt;T&gt; v5 = &#123;a, b, c...&#125; <span class=\"comment\">// 等价于v5&#123;a, b, c...&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意列表初始化和值初始化的区别</span></span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"built_in\">v2</span>(<span class=\"number\">10</span>);    <span class=\"comment\">// 值初始化，v2有10个元素，每个元素都是初始值0</span></span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; v1&#123;<span class=\"number\">10</span>&#125;;    <span class=\"comment\">// 列表初始化，v1有一个元素10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">v3</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">1</span>)</span></span>;  <span class=\"comment\">// v3有10个元素，每个元素值都是1</span></span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; v4&#123;<span class=\"number\">10</span>, <span class=\"number\">1</span>&#125;;  <span class=\"comment\">// v4有2个元素，值分别为10和1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>vector支持的操作</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">v.<span class=\"built_in\">empty</span>();      <span class=\"comment\">// 判断v是否为空，空返回真，否则返回假</span></span><br><span class=\"line\">v.<span class=\"built_in\">size</span>();       <span class=\"comment\">// 返回v中元素的个数</span></span><br><span class=\"line\">v.<span class=\"built_in\">push_back</span>(t); <span class=\"comment\">// 向v的尾端添加一个值为t的元素</span></span><br><span class=\"line\">v[n]            <span class=\"comment\">// 返回v中第n个位置上元素的引用</span></span><br><span class=\"line\">v1 = v2;        <span class=\"comment\">// 用v2中元素的拷贝替换v1中的元素</span></span><br><span class=\"line\">v1 = &#123;a, b, c...&#125;   <span class=\"comment\">// 用列表中元索的拷贝替换v1中的元素</span></span><br><span class=\"line\">v1 == v2        <span class=\"comment\">// v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class=\"line\">&lt;, &lt;=, &gt;, &gt;=    <span class=\"comment\">// 按字典顺序比较</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>vector对象（以及string对象）的下表运算符可以用于访问已存在的元素，不能用于添加元素</p>\n<h3 id=\"迭代器介绍\"><a href=\"#迭代器介绍\" class=\"headerlink\" title=\"迭代器介绍\"></a>迭代器介绍</h3><ol>\n<li><p>使用迭代器</p>\n<p> 与指针不同，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器，end成员则负责返回指向容器尾元素的下一个位置的迭代器，称为尾后迭代器</p>\n<p> 如果容器为空，则begin和end返回的时同一个迭代器，都是尾后迭代器</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">*iter       <span class=\"comment\">// 返回迭代器iter所指元素的引用</span></span><br><span class=\"line\">iter-&gt;mem   <span class=\"comment\">// 解引用iter并获取该元素的名为们的成员，等价于(*iter).mem</span></span><br><span class=\"line\">++iter      <span class=\"comment\">// 令iter指示容器中的下一个元素</span></span><br><span class=\"line\">--iter      <span class=\"comment\">// 令iter指示容器中的上一个元素</span></span><br><span class=\"line\">iter1 == iter2  <span class=\"comment\">// 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元</span></span><br><span class=\"line\">iter1 != iter2  <span class=\"comment\">// 素或者它们是同一个容器的尾后迭代器，则相等；反之，不相等</span></span><br></pre></td></tr></table></figure>\n<p> 迭代器和指针类似，也能通过解引用来获取所指示的元素，但执行解引用的迭代器必须合法且指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为</p>\n<ul>\n<li><p>迭代器类型</p>\n<p>  就像不知道string和vector的size_type成员到底是什么类型一样，一般来说我们也不知道（其实是无须知道）迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用iterator和const iterator来表示迭代器的类型</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt;::iterator it1;  <span class=\"comment\">// it1能读写vector&lt;int&gt;中的元素</span></span><br><span class=\"line\">string::iterator it2;       <span class=\"comment\">// it2能读写string对象中的字符</span></span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt;::const_iterator it3; <span class=\"comment\">// it3只能读，不能写</span></span><br><span class=\"line\">string::const_iterator it4;       <span class=\"comment\">// it4只能读，不能写</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为便于得到const_iterator的返回值，C++11引入了两个新函数</span></span><br><span class=\"line\">v.<span class=\"built_in\">cbegin</span>()          <span class=\"comment\">// 类似于v.begin()，但返回值为const_iterator类型</span></span><br><span class=\"line\">v.<span class=\"built_in\">cend</span>()            <span class=\"comment\">// 类似于v.end()，但返回值为const_iterator类型</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结合解引用和成员访问操作</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">(*it).<span class=\"built_in\">empty</span>();      <span class=\"comment\">// 解引用it，并调用结果对象的empty成员</span></span><br><span class=\"line\">*it.<span class=\"built_in\">empty</span>();        <span class=\"comment\">// 错误，试图访问it的empty成员，但it是迭代器，没有empty成员</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 箭头运算符（-&gt;）把解引用和访问两个操作结合在一起</span></span><br><span class=\"line\">it-&gt;<span class=\"built_in\">mem</span></span><br><span class=\"line\">(*it).mem       <span class=\"comment\">// 以上两句话表达意思相同</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>迭代器运算</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">iter + n        <span class=\"comment\">// 迭代器加上一个整数结果仍是一个迭代器，新位置相比原先向后移动了n个元素</span></span><br><span class=\"line\">iter - n        <span class=\"comment\">// 迭代器减去一个整数结果仍是一个迭代器，新位置相比原先向前移动了n个元素</span></span><br><span class=\"line\">iter += n       <span class=\"comment\">// 迭代器加法的复合赋值语句</span></span><br><span class=\"line\">iter -= n       <span class=\"comment\">// 迭代器减法的复合赋值语句</span></span><br><span class=\"line\">iter1 - iter2   <span class=\"comment\">// 两个迭代器相减的结果是它们之间的距离，即将右侧的迭代器向前移动差值个元素后得到左侧的迭代器</span></span><br><span class=\"line\">&gt;, &gt;=, &lt;, &lt;=    <span class=\"comment\">// 迭代器关系运算符，如果某迭代器所指位置在另一个迭代器之前，则是前者小于后者</span></span><br><span class=\"line\"><span class=\"comment\">// 以上参与运算的迭代器必须指向同一个容器中的元素</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ol>\n<li><p>定义和初始化内置数组</p>\n<p> 定义数组时必须指定数组的类型，不允许用auto关键词由初始值的列表推断类型。 另外，和vector一样，数组的元素应为对象，因此不存在引用的数组。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显式初始化数组元素</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a1[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;   <span class=\"comment\">// 含有三个元素的数组，元素值分别为0, 1, 2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a2[<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;  <span class=\"comment\">// 同上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a2[<span class=\"number\">5</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;  <span class=\"comment\">// 含有五个元素的数组，前三个元素值分别为0, 1, 2，其余元素为默认初始值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符数组的特殊性</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a1[] = &#123;<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;+&#x27;</span>, <span class=\"string\">&#x27;+&#x27;</span>&#125;;    <span class=\"comment\">// 列表初始化，没有空字符</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a2[] = &#123;<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;+&#x27;</span>, <span class=\"string\">&#x27;+&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;  <span class=\"comment\">// 列表初始化，含有显式的空字符</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a3[] = <span class=\"string\">&quot;C++&quot;</span>;              <span class=\"comment\">// 自动添加表示字符串结束的空字符</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a4[<span class=\"number\">6</span>] = <span class=\"string\">&quot;Daniel&quot;</span>;          <span class=\"comment\">// 错误，没有空间存放空字符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b[] = a;            <span class=\"comment\">// 错误：不允许使用一个数组初始化另一个数组</span></span><br><span class=\"line\">b = a;                  <span class=\"comment\">// 错误：不能把一个数组直接赋值给另一个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复杂类型的数组声明</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *ptrs[<span class=\"number\">10</span>];          <span class=\"comment\">// ptrs是含有10个整型指针的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;refs[<span class=\"number\">10</span>] = ...     <span class=\"comment\">// 错误，不存在引用的数组</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">int</span></span> (*Parray)[<span class=\"number\">10</span>];      <span class=\"comment\">// (*Parray)表示Parray是一个指针，该指针指向一个含有10个整数的数组</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">int</span></span> (&amp;arrRef)[<span class=\"number\">10</span>] = arr;<span class=\"comment\">// (&amp;arrRef)表示arrRef是一个引用，其引用的对象是一个大小为10的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *(&amp;arry)[<span class=\"number\">10</span>] = ptrs;<span class=\"comment\">// arry是一个引用，其引用的对象是一个大小为10的数组，其引用对象类型是int型指针，故arry是一个含有10个int型指针的数组的引用</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问数组元素</p>\n<p> 与标准库类型vector和string一样，数组的元素也能使用范围for语句或下标运算符来访问。数组的索引从0开始，以一个包含10个元素的数组为例，它的索引从0到9，而非从1到10。</p>\n</li>\n<li><p>指针和数组</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string nums[] = &#123;<span class=\"string\">&quot;one&quot;</span>, <span class=\"string\">&quot;two&quot;</span>, <span class=\"string\">&quot;three&quot;</span>&#125;;    </span><br><span class=\"line\">string *p = &amp;nums[<span class=\"number\">0</span>];       <span class=\"comment\">// p指向nums的第一个元素</span></span><br><span class=\"line\">string *p2 = nums;          <span class=\"comment\">// 等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>\n<p> 指向数组元素的指针也支持vector和string的迭代器所支持的运算</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p = arr;   <span class=\"comment\">// p指向arr的第一个元素</span></span><br><span class=\"line\">++p;            <span class=\"comment\">// p指向下一个元素</span></span><br><span class=\"line\"><span class=\"comment\">// 指针可以类似尾后迭代器取尾元素下一位置的地址，但这个尾后指针不指向具体的元素，因此不能对其执行解引用或递增等操作</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *e = &amp;arr[<span class=\"number\">10</span>];  <span class=\"comment\">// 指向arr尾元素下一位置的指针，尾后指针</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> *b = arr; b != e; ++b)     <span class=\"comment\">// 尾后指针可以用来判断遍历的结束</span></span><br><span class=\"line\">    cout &lt;&lt; *b &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>标准库函数begin和end</p>\n<p>  尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>&#125;;  <span class=\"comment\">// ia是一个含有10个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *beg = <span class=\"built_in\">begin</span>(ia);       <span class=\"comment\">// 指向ia首元素的指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *last = <span class=\"built_in\">end</span>(ia);        <span class=\"comment\">// 指向arr尾元素下一位置的指针</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解引用和指针运算的交互</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ia[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;     <span class=\"comment\">// 含有5个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> last = *(ia + <span class=\"number\">4</span>);           <span class=\"comment\">// 正确，last为ia[4]的值，即8</span></span><br><span class=\"line\">last = *ia + <span class=\"number\">4</span>;         <span class=\"comment\">// 正确，last为ia[0] + 4 = 0 + 4</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>C风格字符串</p>\n<p> 存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中，其中每个字符都位于自己的数组元素中。C-风格字符串具有一种特殊的性质：以空字符（null character）结尾，空字符被写作\\0，起ASCII码为0，用来标记字符串的结尾。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> dog[<span class=\"number\">5</span>] = &#123;<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;g&#x27;</span>&#125;;  <span class=\"comment\">// 不是字符串</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> cat[<span class=\"number\">5</span>] = &#123;<span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;t&#x27;</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;    <span class=\"comment\">// 是字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> bird[<span class=\"number\">5</span>] = <span class=\"string\">&quot;bird&quot;</span>;      <span class=\"comment\">// 结尾自动包含\\0</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> fish[] = <span class=\"string\">&quot;fish&quot;</span>;       <span class=\"comment\">// 让编译器自动计数</span></span><br></pre></td></tr></table></figure>\n<p> C风格字符串的比较等操作与string不同，不能直接使用运算符==, &gt;, &lt;等，C语言标准库提供了一组可用于操作C风格字符串的函数。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 头文件为cstring, 是C语言头文件string.h的C++版本</span></span><br><span class=\"line\"><span class=\"built_in\">strlen</span>(p)       <span class=\"comment\">// 返回p的长度，不包括空字符</span></span><br><span class=\"line\"><span class=\"built_in\">strcmp</span>(p1, p2)  <span class=\"comment\">// 比较pl和p2的相等性。如果p1==p2，返回0；如果pl&gt;p2，返回一个正值；如果pl&lt;p2，返回一个负值</span></span><br><span class=\"line\"><span class=\"built_in\">strcat</span>(p1, p2)  <span class=\"comment\">// 将p2附加到p1之后，返回p1</span></span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(p1, p2)  <span class=\"comment\">// 将p2拷贝给，返回p1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与旧代码的接口</p>\n<ul>\n<li><p>混用string对象和C风格字符串</p>\n<p>  string对象的使用过程中，大部分情况都可以用C风格字符串替代：</p>\n<ul>\n<li><p>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值</p>\n</li>\n<li><p>在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象</p>\n<p>但对于需要C风格字符串的地方，无法直接用string对象来替代它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;Hello World&quot;</span>)</span></span>;    <span class=\"comment\">// 使用字符串字面值初始化string对象</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *str = s;      <span class=\"comment\">// 错误，不能用string对象初始化char*</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str = s.<span class=\"built_in\">c_str</span>();    <span class=\"comment\">// 正确，c_str函数的返回值是一个C风格的字符串</span></span><br><span class=\"line\"><span class=\"comment\">// 我们无法保证cstr函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>使用数组初始化vector对象</p>\n<p>不允许使用一个数组为另一个内置类型的数组赋初值，也不允许用vector对象初始化数组。但允许用数组来初始化vector对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> int_arr[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ivec</span><span class=\"params\">(begin(int_arr), end(int_arr))</span></span>;     <span class=\"comment\">// 拷贝所有元素</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">subVec</span><span class=\"params\">(int_arr + <span class=\"number\">1</span>, int_arr + <span class=\"number\">4</span>)</span></span>;       <span class=\"comment\">// 拷贝三个元素：int_arr[1]/[2]/[3]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h3><p>严格来说，C++中没有多维数组，通常所说的多维数组其实是数组的数组。</p>\n<p>对于二维数组来说，常把第一个维度称作行，第二个维度称作列。</p>\n<ul>\n<li><p>多维数组的初始化</p>\n<p>  和普通数组一样，允许使用花括号括起来的一组值初始化多维数组</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ia[<span class=\"number\">3</span>][<span class=\"number\">4</span>] = &#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;,   <span class=\"comment\">// 第一行的初始值</span></span><br><span class=\"line\">    &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;,   <span class=\"comment\">// 第二行</span></span><br><span class=\"line\">    &#123;<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>&#125;  <span class=\"comment\">// 第三行</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 没有标识每行的花括号，与之前的初始化语句是等价的</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia[<span class=\"number\">3</span>][<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省略一层花括号，标识只显式初始化第1行</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ix[<span class=\"number\">3</span>][<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多维数组的下标引用</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">int</span></span> (&amp;row)[<span class=\"number\">3</span>] = a[<span class=\"number\">1</span>];      <span class=\"comment\">// row是一个含有3个整数的数组的引用，将其与二维数组的a[1]行绑定</span></span><br><span class=\"line\">cout &lt;&lt; row[<span class=\"number\">2</span>];         <span class=\"comment\">// 取row的第二个元素，也即a[1][2]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用范围for循环处理多维数组</p>\n<p>  要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;row : a) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;col : row) &#123;</span><br><span class=\"line\">        col = cnt++;</span><br><span class=\"line\">        cout &lt;&lt; col &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">        cout &lt;&lt; a[i][j] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">使用引用类型，对a的值进行修改</span></span><br><span class=\"line\"><span class=\"comment\">输出为：</span></span><br><span class=\"line\"><span class=\"comment\">0 1 2 </span></span><br><span class=\"line\"><span class=\"comment\">3 4 5</span></span><br><span class=\"line\"><span class=\"comment\">0 1 2</span></span><br><span class=\"line\"><span class=\"comment\">3 4 5</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;row : a) </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> col : row) </span><br><span class=\"line\">        ...</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) </span><br><span class=\"line\">        ...</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">没有对修改的变量进行引用，a的值不会改变</span></span><br><span class=\"line\"><span class=\"comment\">输出为：</span></span><br><span class=\"line\"><span class=\"comment\">0 1 2 </span></span><br><span class=\"line\"><span class=\"comment\">3 4 5</span></span><br><span class=\"line\"><span class=\"comment\">0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> row : a) </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> col : row) </span><br><span class=\"line\">        ...</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) </span><br><span class=\"line\">        ...</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">外层循环的控制变量没有声明称引用类型，数组可能被自动转成指针，row的类型即为int*，导致内存循环不合法，编译器会报错</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指针和多维数组</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ia[<span class=\"number\">3</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">int</span></span> (*p)[<span class=\"number\">4</span>] = ia;   <span class=\"comment\">// p是指向含有4个整数的数组的指针</span></span><br><span class=\"line\">p = &amp;ia[<span class=\"number\">2</span>];         <span class=\"comment\">// p指向ia[2]这一行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意圆括号，区分是指针数组还是指向数组的指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *ip[<span class=\"number\">4</span>];     <span class=\"comment\">// 整型指针的数组，4个指针</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">int</span></span> (*ip)[<span class=\"number\">4</span>];   <span class=\"comment\">// 指向含有4个整数的数组的1个指针</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h2><p>根据作用于运算对象的个数，分为一元/二元/三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制</p>\n<ol>\n<li><p>运算对象转换</p>\n<p> 尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多时候即使运算对象的类型不相同也没有关系，只要它们能被转换成同一种类型即可。</p>\n<p> 通常小整数类型会被提升成较大的整数类型</p>\n</li>\n<li><p>左值和右值</p>\n<p> C++表达式要么是左值，要么是右值。当一个对象被用作右值时用的是<strong>对象的值</strong>；当被用作左值时，用的是<strong>对象的存储空间</strong>。左值可以当右值使用，但右值不可以当左值使用。</p>\n</li>\n<li><p>求值顺序</p>\n<p> 优先级规定了运算对象的组合方式，但没有说明运算对象按照什么顺序求值。对于类似 <script type=\"math/tex\">i = f1() * f2()</script> 的表达式，f1和f2的调用顺序是未知的，如果在函数中有对同一对象进行读写，可能会产生不可预知的错误。在不确定运算顺序是，最好用括号强制让表达式的组合关系符合程序逻辑要求。</p>\n<p> 有4种运算符明确规定了运算对象的求值顺序：</p>\n<pre><code> - L&amp;&amp;R\n\n     先求L的值，只有当L的值为真时才继续求R的值\n\n - L||R\n\n     先求L的值，只有当L的值为假时才继续求R的值\n\n - V?L:R\n\n     先计算V，V为真计算L，V为假计算R（另一个不计算）\n\n - L,R\n\n     先计算L，再计算R，两者均会被计算\n</code></pre></li>\n<li><p>成员访问运算符</p>\n<ul>\n<li><p>点运算符</p>\n<p>  点运算符获取类对象的一个成员</p>\n</li>\n<li><p>箭头运算符</p>\n<p>  ptr -&gt; mem 等价于 (*ptr).mem</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string s1 = <span class=\"string\">&quot;a string&quot;</span>, *p = &amp;s1;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> n = s1.<span class=\"built_in\">size</span>();         <span class=\"comment\">// 运行string对象s1的size成员</span></span><br><span class=\"line\">n = (*p).<span class=\"built_in\">size</span>();            <span class=\"comment\">// 运行p所指对象的size成员</span></span><br><span class=\"line\">n = p -&gt; <span class=\"built_in\">size</span>();            <span class=\"comment\">// 等价于(*p).size()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号</span></span><br><span class=\"line\">*p.<span class=\"built_in\">szie</span>();                  <span class=\"comment\">// 错误，p是一个指针，它没有名为size的成员</span></span><br></pre></td></tr></table></figure>\n<p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。</p>\n<p>点运算符的结果与成员所属的对象相关：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值</p>\n</li>\n</ul>\n</li>\n<li><p>位运算符</p>\n<p> |  运算符   |  功能  |<br> |  ——  |  ——  |<br> |  ~  |  取反  |<br> |  &lt;&lt;  |  左移  |<br> |  &gt;&gt;  |  右移  |<br> |  &amp;  |  按位与  |<br> |  ^  |  异或  |</p>\n</li>\n</ol>\n<h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><h3 id=\"简单语句\"><a href=\"#简单语句\" class=\"headerlink\" title=\"简单语句\"></a>简单语句</h3><ul>\n<li><p>空语句</p>\n<p>  最简单的语句是空语句，空语句中只含有一个单独的分号</p>\n</li>\n<li><p>复合语句</p>\n<p>  复合语句指用花括号空起来（可能为空）的语句和声明，复合语句也被称做<strong>块</strong></p>\n</li>\n</ul>\n<h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><ol>\n<li><p>if语句</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition)</span><br><span class=\"line\">    <span class=\"function\">statement</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">if</span> <span class=\"params\">(condition)</span></span></span><br><span class=\"line\"><span class=\"function\">    statement1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"function\">    statement2</span></span><br></pre></td></tr></table></figure>\n<p> C++规定else与离它最近的尚未匹配的if匹配</p>\n</li>\n<li><p>switch语句</p>\n<p> case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">switch</span></span> (ch) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>switch内部的控制流</p>\n<p>  如果某个case标签匹配成功，程序将从标签开始往后顺序执行所有case分支，除非程序显式地中断了这一过程。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当希望多个值共享同一组操作时，可以利用switch默认的行为，故意省略掉break语句</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">switch</span></span> (ch) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">        ...     <span class=\"comment\">// 当标签为a,b,c其中之一时，均执行此操作</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">switch</span></span> (ch) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 另一种合法的写法</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>: <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>: <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"迭代语句\"><a href=\"#迭代语句\" class=\"headerlink\" title=\"迭代语句\"></a>迭代语句</h3><p>迭代语句通常称为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环休，然后再检查条件。</p>\n<ol>\n<li><p>while语句</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (condition)</span><br><span class=\"line\">    statement</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传统for语句</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (init-statement; condition; expression)</span><br><span class=\"line\">    statement</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// init-statement: 循环开始时执行一次，一般为初始化，可以省略</span></span><br><span class=\"line\"><span class=\"comment\">// condition: 循环控制条件，如果为真，执行statement；如果为假，结束循环。可以省略</span></span><br><span class=\"line\"><span class=\"comment\">// expression: 每次循环迭代之后执行该语句，一般用于修改控制循环的变量，可以省略</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>范围for语句</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (declaration: expression)</span><br><span class=\"line\">    statement</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// expression: 待遍历的序列</span></span><br><span class=\"line\"><span class=\"comment\">// declaration: 定义一个变量，序列中的每个元素都能转换成该变量的类型。</span></span><br><span class=\"line\"><span class=\"comment\">// 每次迭代会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>do while语句</p>\n<p> 注意，statement中使用的变量，不应该在条件(conditong)部分定义</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">do</span></span></span><br><span class=\"line\"><span class=\"function\">    statement</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">while</span> <span class=\"params\">(condition)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h3><ol>\n<li><p>break语句</p>\n<p> break语句负责终止离他最近的while, do while, for 或 switch语句，并从这些语句之后的第一条语句开始继续执行</p>\n</li>\n<li><p>continue语句</p>\n<p> continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue只能出现在for, while 和 do while 循环内部，或者嵌套在此类循环里的语句或块的内部</p>\n</li>\n<li><p>goto语句</p>\n<p> goto语句的作用是从goto语句无条件跳转到同一函数内的另一条语句</p>\n<blockquote>\n<p>“不要再程序中使用goto语句，因为它使得程序既难理解又难修改”</p>\n</blockquote>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">goto</span> label; <span class=\"comment\">// label是用于标识一条语句的标识符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">begin:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt;= <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">        x++;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> begin;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p> goto向后跳过一个已执行的定义是合法的。跳回变量定义之前意味着系统将销毁该变量，然后重新创建它。注意不要跳过会使用的变量的声明</p>\n</li>\n</ol>\n<h3 id=\"try语句块和异常处理\"><a href=\"#try语句块和异常处理\" class=\"headerlink\" title=\"try语句块和异常处理\"></a>try语句块和异常处理</h3><p>P173 暂略</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"函数基础\"><a href=\"#函数基础\" class=\"headerlink\" title=\"函数基础\"></a>函数基础</h3><p>一个典型的函数（function）定义包括以下部分：返回类型(returntype)、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。</p>\n<ol>\n<li><p>局部对象</p>\n<p> 形参和函数体内部定义的变量统称为<strong>局部对象</strong></p>\n<ul>\n<li><p>自动对象</p>\n<p>  对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为<strong>自动对象</strong>。形参是一种自动对象，函数开始时为其申请存储空间，函数终止形参也被销毁</p>\n</li>\n<li><p>局部静态对象</p>\n<p>  某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。<strong>局部静态对象</strong>在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">count_calls</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> ctr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++ctr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"built_in\">count_calls</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序输出为1~10</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>分离式编译</p>\n<p> 分离式编译允许编写程序时按照逻辑关系将其分割到几个文件中去，每个文件独立编译</p>\n</li>\n</ol>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><ol>\n<li><p>传值参数</p>\n<p> 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>或者函数被<strong>传值调用</strong>。</p>\n<ul>\n<li><p>指针形参</p>\n<p>  指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针也可以修改它所指对象的值</p>\n</li>\n</ul>\n</li>\n<li><p>传引用参数</p>\n<p> 当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>或者函数被<strong>传引用调用</strong>。和其他引用一样，引用形参也是它绑定的对象的别名：也就是说，引用形参是它对应的实参的别名。</p>\n<ul>\n<li><p>使用引用避免拷贝</p>\n<p>  拷贝打的类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝操作。这时使用引用形参是比较明智的选择</p>\n<p>  <strong>如果函数无需改变引用形参的值，最好将其声明为常量引用</strong></p>\n</li>\n</ul>\n</li>\n<li><p>const形参和实参</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fcn</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    fcn能够读取i，但不能向i写值</span></span><br><span class=\"line\"><span class=\"comment\">    调用fcn()时，可以传入const int也可以传入int</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数组形参</p>\n<p> 数组有两个特殊性质：不允许拷贝数组，以及使用数组时（通常）会将其转换成指针。所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 尽管不能以值传递的方式传递数组，但我们可以把形参写成类似数组的形式</span></span><br><span class=\"line\"><span class=\"comment\">// 以下三种写法是等价的，每一个函数都有一个const int*类型的形参</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>*)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>[])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>])</span>   <span class=\"comment\">// 这里的维度表示我们期望数组含有多少元素，实际不一定</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>传递多维数组</p>\n<p>  当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> (*matrix)[<span class=\"number\">10</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 注意括号一定不能省略</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *matrix[10]</span>;    <span class=\"comment\">// 10个指针的数组</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">int</span></span> (*matrix)[<span class=\"number\">10</span>];  <span class=\"comment\">// 1个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>含有可变形参的函数</p>\n<p> 无法提前预知应该向函数传递几个实参时，则需要使用到含有可变形参的函数</p>\n<p> C++11新标准提供了两种方法：1. 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；2. 如果实参的类型不同，可以编写可变参数模板</p>\n</li>\n</ol>\n<h3 id=\"返回类型和return语句\"><a href=\"#返回类型和return语句\" class=\"headerlink\" title=\"返回类型和return语句\"></a>返回类型和return语句</h3><ul>\n<li><p>不要返回局部对象的引用或指针</p>\n<p>  函数完成后，它占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 严重错误，这个函数试图返回局部对象的引用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> string &amp;<span class=\"title\">manip</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    string ret;</span><br><span class=\"line\">    ... <span class=\"comment\">// 对ret执行某种操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret; <span class=\"comment\">// 错误，返回局部对象的调用</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Empty&quot;</span>; <span class=\"comment\">// 错误，&quot;Empty&quot;是一个局部临时量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>引用返回左值</p>\n<p>  函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值。</p>\n</li>\n<li><p>返回数组指针</p>\n<p>  因为数组不能被拷贝，所以函数不能返回数组。以下是可行方案：</p>\n<pre><code>  - 声明一个返回数组指针的函数\n\n      <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>];    <span class=\"comment\">// arr是一个含有10个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1[<span class=\"number\">10</span>];    <span class=\"comment\">// p1是一个含有10个指针的数组</span></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">int</span></span> (*p2)[<span class=\"number\">10</span>];  <span class=\"comment\">// p2是一个指针，指向含有10个整数的数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与变量声明相同，如果想定义返回数组指针的函数，数组的维度应该跟在函数名之后</span></span><br><span class=\"line\"><span class=\"built_in\">Type</span> (*<span class=\"built_in\">function</span>(parameter_list))[dimension]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">int</span></span> (*<span class=\"built_in\">func</span>(<span class=\"keyword\">int</span> i))[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">// func(int i)表示调用改函数时需要一个int类型的实参</span></span><br><span class=\"line\"><span class=\"comment\">// (*func(int i))表示可以对函数调用的结果进行解引用操作（函数返回的是一个指针？）</span></span><br><span class=\"line\"><span class=\"comment\">// (*func(int i))[10]表示解引用得到的是一个大小为10的数组（指针指向一个大小为10的数组？）</span></span><br><span class=\"line\"><span class=\"comment\">// int (*func(int i))[10]表示数组中元素的类型是int</span></span><br></pre></td></tr></table></figure>\n\n  - 使用尾置返回类型\n\n      <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> -&gt; <span class=\"title\">int</span> <span class=\"params\">(*)</span>[10]</span>;</span><br><span class=\"line\">    ``</span><br><span class=\"line\"></span><br><span class=\"line\">- 使用<span class=\"keyword\">decltype</span></span><br><span class=\"line\"></span><br><span class=\"line\">    如果我们知道函数返回的指针将指向那个数组，可以使用<span class=\"keyword\">decltype</span>关键字声明返回类型</span><br><span class=\"line\"></span><br><span class=\"line\">    ```c++</span><br><span class=\"line\">    <span class=\"keyword\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">decltype</span>(odd) *<span class=\"built_in\">arrPtr</span>(<span class=\"keyword\">int</span> i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? &amp;odd : &amp;even;  <span class=\"comment\">// 返回一个指向数组的指针</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    #include&lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    using namespace std;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    int odd[] = &#123;1, 3, 5, 7, 9&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    int even[] = &#123;0, 2, 4, 6, 8&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    // 返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class=\"line\"><span class=\"comment\">    decltype(odd) *arrPtr(int i)</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return (i % 2) ? &amp;odd : &amp;even;  // 返回一个指向数组的指针</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    int main()</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        int (*p)[5] = arrPtr(5);</span></span><br><span class=\"line\"><span class=\"comment\">        for (int i = 0; i &lt; 5; i++)</span></span><br><span class=\"line\"><span class=\"comment\">            cout &lt;&lt; (*p)[i] &lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"comment\">        return 0;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br></pre></td></tr></table></figure>\n</code></pre></li>\n</ul>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载函数</strong></p>\n<ul>\n<li><p>判断形参类型是否相同</p>\n<p>  有时候两个形参列表看起来不一样，但实际上是相同的</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(<span class=\"keyword\">const</span> Account &amp;acct)</span></span></span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(<span class=\"keyword\">const</span> Account &amp;)</span>    <span class=\"comment\">// 省略了形参的名字</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> Phone Telno</span>;</span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(<span class=\"keyword\">const</span> Phone&amp;)</span></span></span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(<span class=\"keyword\">const</span> Telno&amp;)</span>   <span class=\"comment\">// Telno和Phone类型相同</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重载和const形参</p>\n<p>  顶层const不影响传输函数的对象，故一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(Phone)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(<span class=\"keyword\">const</span> Phone)</span></span>;     <span class=\"comment\">// 重复声明了Record lookup(Phone)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(Phone*)</span></span></span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(Phone* <span class=\"keyword\">const</span>)</span></span>;    <span class=\"comment\">// 重复声明了Record lookup(Phone*)</span></span><br></pre></td></tr></table></figure>\n<p>  另一方面，如果形参时某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同</span></span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(Account&amp;)</span></span></span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(<span class=\"keyword\">const</span> Account&amp;)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(Account*)</span></span></span><br><span class=\"line\"><span class=\"function\">Record <span class=\"title\">lookup</span><span class=\"params\">(cosnt Account*)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"特殊用途语句特性\"><a href=\"#特殊用途语句特性\" class=\"headerlink\" title=\"特殊用途语句特性\"></a>特殊用途语句特性</h3><ol>\n<li><p>默认实参</p>\n<p> 默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，但一旦某个形参被赋予了默认值，它后面所有的形参都必须有默认值</p>\n</li>\n<li><p>内联函数和constexpr函数</p>\n<p> 将一些重复操作定义成函数有很多好处，但也存在一个潜在的缺点：调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含这一些列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。</p>\n<ul>\n<li><p>内联函数可避免函数调用的开销</p>\n<p>  将函数指定为内联函数(inline)，通常就是将它在每个调用点上“内联地”展开。</p>\n<blockquote>\n<p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求</p>\n</blockquote>\n<p>  一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。</p>\n</li>\n<li><p>constrexpr函数</p>\n<p>  constrexpr函数是能指用于常量表达式的函数：</p>\n<ul>\n<li><p>函数的返回类型及所有形参的类型都得是字面值类型</p>\n</li>\n<li><p>函数中必须有且只有一条return语句</p>\n</li>\n<li><p>允许constexpr函数的返回值并非一个常量</p>\n<blockquote>\n<p>（constexpr函数不一定返回常量表达式）</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> <span class=\"title\">new_sz</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则不然</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">size_t</span> <span class=\"title\">scale</span><span class=\"params\">(<span class=\"keyword\">size_t</span> cnt)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">new_sz</span>() * cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> foo = <span class=\"built_in\">new_sz</span>();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[<span class=\"built_in\">scale</span>(<span class=\"number\">2</span>)];  <span class=\"comment\">// 正确，scale(2)是常量表达式</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[<span class=\"built_in\">scale</span>(i)];  <span class=\"comment\">// 错误，scale(i)不是常量表达式</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>内敛函数和constexpr函数可以在程序中多次定义。但对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致，故<strong>内联函数和constexpr函数通常定义在头文件中</strong></p>\n</li>\n</ul>\n</li>\n<li><p>调试帮助</p>\n<p> assert，NDEBUG</p>\n<p> P241 暂略</p>\n</li>\n</ol>\n<h3 id=\"函数匹配\"><a href=\"#函数匹配\" class=\"headerlink\" title=\"函数匹配\"></a>函数匹配</h3><p>步骤：</p>\n<ol>\n<li><p>选定本次调用对应的重载函数集，集合中的函数称为<strong>候选函数</strong></p>\n</li>\n<li><p>考察本次调用提供的实参，从候选函数中选出能被调用的函数，这些新选出的函数称为<strong>可行函数</strong></p>\n</li>\n<li><p>从可行函数中选择与本次调用最匹配的函数</p>\n</li>\n</ol>\n<p>当实参的数量超过两个，或者存在默认实参等情况，函数匹配会变得复杂。可能出现二义性，要注意避免。</p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><p>P248 暂略</p>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。</p>\n<p>数据抽象是一种依赖于<strong>接口</strong>和<strong>实现</strong>分离的编程技术。</p>\n<h3 id=\"定义抽象数据类型\"><a href=\"#定义抽象数据类型\" class=\"headerlink\" title=\"定义抽象数据类型\"></a>定义抽象数据类型</h3><ol>\n<li><p>成员函数</p>\n<p> 成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。</p>\n<blockquote>\n<p>定义在类内部的函数是隐式的inline函数</p>\n</blockquote>\n<ul>\n<li><p>this，const成员函数</p>\n<p>  暂略</p>\n</li>\n</ul>\n</li>\n<li><p>构造函数</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以第一章Sales_data为例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sales_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>() = <span class=\"keyword\">default</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 构造函数初始值列表</span></span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(<span class=\"keyword\">const</span> std::string &amp;s): <span class=\"built_in\">bookNo</span>(s) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(<span class=\"keyword\">const</span> std::string &amp;s, <span class=\"keyword\">unsigned</span> n, <span class=\"keyword\">double</span> p):</span><br><span class=\"line\">        <span class=\"built_in\">bookNo</span>(s), <span class=\"built_in\">units_sold</span>(n), <span class=\"built_in\">revenue</span>(p*n) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"访问控制与封装\"><a href=\"#访问控制与封装\" class=\"headerlink\" title=\"访问控制与封装\"></a>访问控制与封装</h3><p>C++中使用<strong>访问说明符</strong>加强类的封装性：</p>\n<ul>\n<li><p>public：整个程序内可被访问，public成员定义类的接口</p>\n</li>\n<li><p>private：可以被类的成员函数访问，但不能被使用该类的代码访问，private部分封装（隐藏）了类的实现细节</p>\n</li>\n</ul>\n<p><strong>class和struct关键字</strong></p>\n<p>使用class和struct关键字都可以定义类，区别在于它们的默认访问权限不一样。struct定义在第一个访问说明符之前的成员是public的，class则是private的</p>\n<blockquote>\n<p>使用class和struct定义类唯一的区别就是默认的访问权限</p>\n</blockquote>\n<ol>\n<li><p>友元</p>\n<p> 类可以允许其他类或函数访问它的非公有成员，方法是令其他类或者函数成为它的<strong>友元</strong></p>\n<p> 如果类想把一个函数作为它的友元，需要在其声明语句前添加friend关键字</p>\n<blockquote>\n<p>友元声明只能出现在类定义的内部，具体位置不限。一般来说，最好在类定义开始或结束前的位置集中声明友元</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"类的其他特性\"><a href=\"#类的其他特性\" class=\"headerlink\" title=\"类的其他特性\"></a>类的其他特性</h3><p>暂略 P269</p>\n<h3 id=\"类的作用域\"><a href=\"#类的作用域\" class=\"headerlink\" title=\"类的作用域\"></a>类的作用域</h3><h3 id=\"构造函数再探\"><a href=\"#构造函数再探\" class=\"headerlink\" title=\"构造函数再探\"></a>构造函数再探</h3><h3 id=\"类的静态成员\"><a href=\"#类的静态成员\" class=\"headerlink\" title=\"类的静态成员\"></a>类的静态成员</h3><p>类中由static修饰的成员，为类的静态成员。类的静态成员属于类而不是对象，它是该类型所有对象所共享的。</p>\n<p>P294</p>\n<h1 id=\"C-标准库\"><a href=\"#C-标准库\" class=\"headerlink\" title=\"C++标准库\"></a>C++标准库</h1><h2 id=\"IO库\"><a href=\"#IO库\" class=\"headerlink\" title=\"IO库\"></a>IO库</h2><h3 id=\"IO类\"><a href=\"#IO类\" class=\"headerlink\" title=\"IO类\"></a>IO类</h3><h3 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h3><h3 id=\"string流\"><a href=\"#string流\" class=\"headerlink\" title=\"string流\"></a>string流</h3><h2 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h2><h3 id=\"顺序容器概述\"><a href=\"#顺序容器概述\" class=\"headerlink\" title=\"顺序容器概述\"></a>顺序容器概述</h3><h3 id=\"容器库概览\"><a href=\"#容器库概览\" class=\"headerlink\" title=\"容器库概览\"></a>容器库概览</h3><h3 id=\"顺序容器操作\"><a href=\"#顺序容器操作\" class=\"headerlink\" title=\"顺序容器操作\"></a>顺序容器操作</h3><h3 id=\"vector对象是如何增长的\"><a href=\"#vector对象是如何增长的\" class=\"headerlink\" title=\"vector对象是如何增长的\"></a>vector对象是如何增长的</h3><h3 id=\"额外的string操作\"><a href=\"#额外的string操作\" class=\"headerlink\" title=\"额外的string操作\"></a>额外的string操作</h3><h3 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h3><h2 id=\"泛型算法\"><a href=\"#泛型算法\" class=\"headerlink\" title=\"泛型算法\"></a>泛型算法</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><h3 id=\"初识泛型算法\"><a href=\"#初识泛型算法\" class=\"headerlink\" title=\"初识泛型算法\"></a>初识泛型算法</h3><h3 id=\"定制操作\"><a href=\"#定制操作\" class=\"headerlink\" title=\"定制操作\"></a>定制操作</h3><h3 id=\"再探迭代器\"><a href=\"#再探迭代器\" class=\"headerlink\" title=\"再探迭代器\"></a>再探迭代器</h3><h3 id=\"泛型算法结构\"><a href=\"#泛型算法结构\" class=\"headerlink\" title=\"泛型算法结构\"></a>泛型算法结构</h3><h3 id=\"特定容器算法\"><a href=\"#特定容器算法\" class=\"headerlink\" title=\"特定容器算法\"></a>特定容器算法</h3><h2 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h2><h3 id=\"使用关联容器\"><a href=\"#使用关联容器\" class=\"headerlink\" title=\"使用关联容器\"></a>使用关联容器</h3><h3 id=\"关联容器概述\"><a href=\"#关联容器概述\" class=\"headerlink\" title=\"关联容器概述\"></a>关联容器概述</h3><h3 id=\"关联容器操作\"><a href=\"#关联容器操作\" class=\"headerlink\" title=\"关联容器操作\"></a>关联容器操作</h3><h3 id=\"无序容器\"><a href=\"#无序容器\" class=\"headerlink\" title=\"无序容器\"></a>无序容器</h3><h2 id=\"静态内存\"><a href=\"#静态内存\" class=\"headerlink\" title=\"静态内存\"></a>静态内存</h2><h1 id=\"类设计者的工具\"><a href=\"#类设计者的工具\" class=\"headerlink\" title=\"类设计者的工具\"></a>类设计者的工具</h1><h1 id=\"高级主题\"><a href=\"#高级主题\" class=\"headerlink\" title=\"高级主题\"></a>高级主题</h1>","categories":["语言"],"tags":["C++"]},{"title":"Kalman滤波","url":"/2022/07/01/Kalman%EF%BC%88%E5%8D%A1%E5%B0%94%E6%9B%BC%EF%BC%89%E6%BB%A4%E6%B3%A2/","content":"<blockquote>\n<p>百度百科：</p>\n<p>卡尔曼滤波（Kalman filtering）是一种利用<a href=\"https://baike.baidu.com/item/线性系统/6814705\">线性系统</a>状态方程，通过系统输入输出观测数据，对<a href=\"https://baike.baidu.com/item/系统状态/896358\">系统状态</a>进行最优估计的算法。由于观测数据中包括系统中的噪声和干扰的影响，所以最优估计也可看作是<a href=\"https://baike.baidu.com/item/滤波/2938301\">滤波</a>过程。</p>\n</blockquote>\n<h1 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h1><h2 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h2><p>在了解卡曼滤波之前，先设想这样一个场景：有一辆小车，初始位置已知，由于某些因素，我们所知的这个位置并不是确定点，而是存在一定误差，我们认为其位置服从正态分布（不知道为啥是正态分布QAQ）。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081338996.png\" width=\"500\"></p>\n<p>小车的速度已知，所以我们可以根据这个初始位置估计一段时间后小车的位置，这个估计的位置也服从正态分布。由于小车的速度不一定恒定，也可能存在路况等因素的影响，这次位置的不确定性更大，体现在正态分布上即方差更大，函数图像更宽。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081338006.png\" width=\"500\"></p>\n<p>依靠估计来获取小车的位置显然是不太可靠的，所以在小车上安装了雷达装置用以测量小车的位置。雷达测量的数据也不完全准确，我们依然认为其服从正态分布。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081339485.png\" width=\"500\"></p>\n<p>这时，对于小车的新位置，我们拥有两个不同的结果。这两个结果都有其可靠性但也都不完全可靠，如果我们能将这两个结果进行某种结合，得到的新预测值就会更加接近小车的真实位置。Kalman滤波的实质就是将这两个正态分布进行加权平均，得到更接近真实情况的一个新的正态分布。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081339488.png\" width=\"500\"></p>\n<h2 id=\"另一个栗子\"><a href=\"#另一个栗子\" class=\"headerlink\" title=\"另一个栗子\"></a>另一个栗子</h2><p>还有一个更简单的例子来理解Kalman滤波的加权平均思想。</p>\n<p>假设有一个质量为m的物体，现想知道物体的重力大小。你有两个弹簧测力计，问题在于这两个测力计测出的重力值不同，应该如何得到更准确的值？最好的办法是将它们<strong>取平均值</strong>。</p>\n<p>但如果这两个弹簧测力计，一个较为精确价格高昂，另一个则非常便宜，那对于测量出的两个不同值，我们更倾向于相信贵的所测量的结果。这时我们针对这两个数据，就不是完全的取平均，而是有倾向的<strong>取加权平均</strong>。</p>\n<p>问题回到预测和测量。根据所学的物理知识，你知道G = mg(g = 9.8)，所以你认为这个物体的重力为G1。现在你手上有一个弹簧测力计，测量出来的重力为G2。如何取G1和G2的加权平均，取决于你对g=9.8的<strong>确信度</strong>，你对g的确信度越大，它在取加权平均时对应的权值就越大，反之则越小。这个权值在Kalman滤波中也被称之为Kalman系数。</p>\n<h1 id=\"公式推导\"><a href=\"#公式推导\" class=\"headerlink\" title=\"公式推导\"></a>公式推导</h1><p>在上例中，我们记小车真实的状态为 $x_k$</p>\n<p>我们对其状态的估计（红色部分）称为先验估计，因为它是不完整的，还需要后续的调整$\\hat{x}_k^-$</p>\n<p>通过雷达，我们测量得到小车状态（灰色部分），记为$y_k$</p>\n<p>在经过雷达测量后，我们再次对小车的状态进行最终预测（绿色部分），称为后验估计$\\hat{x}_k$</p>\n<p>假设我们对监测数据和估计数据的信任程度三七开，则</p>\n<script type=\"math/tex; mode=display\">\n\\hat{x}_k = 0.3 \\times y_k + (1 - 0.3) \\times \\hat{x}_k^- = \\hat{x}_k^- + 0.3 \\times (y_k - \\hat{x}_k^-)</script><p>将这里的0.3用参数K表示，K即为Kalman系数（K越大，表示越信任监测值）</p>\n<h2 id=\"如何获取状态值\"><a href=\"#如何获取状态值\" class=\"headerlink\" title=\"如何获取状态值\"></a>如何获取状态值</h2><p><strong>状态公式：</strong></p>\n<script type=\"math/tex; mode=display\">\nx_{k} = A x_{k-1} + B u_k</script><p>​        其中，A表示状态转移矩阵，表示如何从上一时刻状态推算当前时刻状态；B为控制矩阵，表示控制量u如何作用于当前状态</p>\n<p>以小车为例，假设小车速度为v，加速度为a，间隔时间为t，小车的位置可得：</p>\n<script type=\"math/tex; mode=display\">\nx_k = x_{k-1} + t \\times v_{k-1} + \\frac{t^2}{2} \\times a_{k-1}</script><ul>\n<li><p>位置和速度构成小车的状态</p>\n<script type=\"math/tex; mode=display\">\nX = \n\\begin{bmatrix}\nx \\\\\nv\n\\end{bmatrix}</script></li>\n<li><p>加速度作为控制量作用于当前状态</p>\n<script type=\"math/tex; mode=display\">\nu = a</script></li>\n<li><p>状态转移矩阵为</p>\n</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nA = \n\\begin{bmatrix}\n1 & t \\\\\n0 & 1\n\\end{bmatrix}</script><ul>\n<li>控制矩阵为：<script type=\"math/tex; mode=display\">\nB = \n\\begin{bmatrix}\n\\frac{1}{2} t^2\\\\\nt\n\\end{bmatrix}</script></li>\n</ul>\n<p>测量值和真实值之间存在某种映射关系，我们将其记为H，<strong>测量方程即为：</strong></p>\n<script type=\"math/tex; mode=display\">\ny_k = H x_k</script><h2 id=\"如何获取预测值的不确定性\"><a href=\"#如何获取预测值的不确定性\" class=\"headerlink\" title=\"如何获取预测值的不确定性\"></a>如何获取预测值的不确定性</h2><p>在真实环境中，无论是估计还是测量都带有一定误差，我们将其视为高斯分布的噪声W，V</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\nx_{k} = A x_{k-1} + B u_k + W \\\\\ny_k = H x_k + V\n\\end{cases}</script><script type=\"math/tex; mode=display\">\nW \\sim N(0, Q) \\\\\nV \\sim N(0, R)</script><h3 id=\"对于估计值\"><a href=\"#对于估计值\" class=\"headerlink\" title=\"对于估计值\"></a>对于估计值</h3><p>根据状态公式，我们的估计值为：</p>\n<script type=\"math/tex; mode=display\">\n\\hat{x}^-_{k} = A \\hat{x}_{k-1} + B u_k</script><p>先验估计误差：</p>\n<script type=\"math/tex; mode=display\">\ne_k^- = x_k - \\hat{x}_k^-</script><p>先验估计误差协方差：</p>\n<script type=\"math/tex; mode=display\">\np_k^- = E [e_k^- e_k^{-T}]</script><p>经过推理计算，会得到以下预测公式</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207192216210.png\" width=\"500\"></p>\n<ul>\n<li><strong>协方差预测公式</strong><script type=\"math/tex; mode=display\">\n{p}^-_k = A p_{k-1} A^T + Q</script></li>\n</ul>\n<h3 id=\"对于测量值\"><a href=\"#对于测量值\" class=\"headerlink\" title=\"对于测量值\"></a>对于测量值</h3><p>显然，测量值的方差为常数R</p>\n<h2 id=\"如何获取Kalman增益（参数K）\"><a href=\"#如何获取Kalman增益（参数K）\" class=\"headerlink\" title=\"如何获取Kalman增益（参数K）\"></a>如何获取Kalman增益（参数K）</h2><p><strong>Kalman参数：</strong></p>\n<script type=\"math/tex; mode=display\">\nK_k = \\frac{p_k^- H^T}{H p_k^- H^T + R}</script><p>推导过程不是很懂，思路可以参考温度计的例子</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081341870.png\" width=\"500\"></p>\n<p>获取Kalman参数后，即可进行<strong>后验估计</strong>：</p>\n<script type=\"math/tex; mode=display\">\n\\hat{x}_k = \\hat{x}_k^- + K_k(y_k - H \\hat{x}_k^-)</script><h2 id=\"更新不确定性\"><a href=\"#更新不确定性\" class=\"headerlink\" title=\"更新不确定性\"></a>更新不确定性</h2><p>得到最终的预测值，便可以更新此次的不确定性：</p>\n<script type=\"math/tex; mode=display\">\np_k = (I - K_k H)p_k^-</script><h1 id=\"Kalman滤波过程\"><a href=\"#Kalman滤波过程\" class=\"headerlink\" title=\"Kalman滤波过程\"></a>Kalman滤波过程</h1><p>将上述推导得出的公式整合起来，就能得到Kalman滤波的过程</p>\n<ol>\n<li>先验状态估计</li>\n</ol>\n<script type=\"math/tex; mode=display\">\n\\hat{x}^-_{k} = A \\hat{x}_{k-1} + B u_k</script><ol>\n<li>先验估计误差协方差</li>\n</ol>\n<script type=\"math/tex; mode=display\">\n{p}^-_k = A p_{k-1} A^T + Q</script><ol>\n<li>计算Kalman增益</li>\n</ol>\n<script type=\"math/tex; mode=display\">\nK_k = \\frac{p_k^- H^T}{H p_k^- H^T + R}</script><ol>\n<li><p>后验状态估计</p>\n<script type=\"math/tex; mode=display\">\n\\hat{x}_k = \\hat{x}_k^- + K_k(y_k - H \\hat{x}_k^-)</script></li>\n<li><p>更新测量误差</p>\n</li>\n</ol>\n<script type=\"math/tex; mode=display\">\np_k = (I - K_k H)p_k^-</script><h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><ol>\n<li><p><strong>OpenCV自带的cv2.KalmanFilter</strong></p>\n<ul>\n<li><p>API</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">cv::KalmanFilter::KalmanFilter(</span><br><span class=\"line\">    <span class=\"built_in\">int</span> dynamParams,  <span class=\"comment\">## 状态维度 (pos, v)</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> measureParams,  <span class=\"comment\">## 测量维度 (pos)</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> controlParams = <span class=\"number\">0</span>,  <span class=\"comment\">## 控制向量 (a)</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> <span class=\"built_in\">type</span> = CV_32F  <span class=\"comment\">## 数据类型</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">K_filter = cv2.KalmanFilter(state_num, measure_num, <span class=\"number\">0</span>)</span><br><span class=\"line\">K_filter.transitionMatrix\t<span class=\"comment\">## 转移矩阵 A</span></span><br><span class=\"line\">K_filter.measurementMatrix  <span class=\"comment\">## 测量矩阵 H</span></span><br><span class=\"line\">K_filter.processNoiseCov\t<span class=\"comment\">## 系统误差 Q</span></span><br><span class=\"line\">K_filter.measurementNoiseCov\t<span class=\"comment\">## 测量误差 R</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>预测 predict()</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">K_filter.predict()\t<span class=\"comment\">## 返回下一时刻预测值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 函数介绍</span></span><br><span class=\"line\">CV_EXPORTS const oclMat&amp; KalmanFilter::predict(const oclMat&amp; control)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">## gemm()为矩阵广义乘法</span></span><br><span class=\"line\">    gemm(transitionMatrix, statePost, <span class=\"number\">1</span>, oclMat(), <span class=\"number\">0</span>, statePre);  <span class=\"comment\">## x`_k = A * x_&#123;k - 1&#125;</span></span><br><span class=\"line\">    oclMat temp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(control.data)  <span class=\"comment\">## 如果B非空</span></span><br><span class=\"line\">        gemm(controlMatrix, control, <span class=\"number\">1</span>, statePre, <span class=\"number\">1</span>, statePre);  <span class=\"comment\">## x`_k += B * u_k</span></span><br><span class=\"line\">    gemm(transitionMatrix, errorCovPost, <span class=\"number\">1</span>, oclMat(), <span class=\"number\">0</span>, temp1);  <span class=\"comment\">## tmp1 = A * p_&#123;k - 1&#125;</span></span><br><span class=\"line\">    gemm(temp1, transitionMatrix, <span class=\"number\">1</span>, processNoiseCov, <span class=\"number\">1</span>, errorCovPre, GEMM_2_T);  <span class=\"comment\">## p_k = tmp1 * A = A * p_&#123;k - 1&#125;*A^T + Q_k</span></span><br><span class=\"line\">    statePre.copyTo(statePost);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> statePre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新（测量）  correct (measurement)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">K_filter.<span class=\"built_in\">correct</span>(measurement)  <span class=\"comment\">// 输入测量量（更新）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数介绍</span></span><br><span class=\"line\"><span class=\"function\">CV_EXPORTS <span class=\"keyword\">const</span> oclMat&amp; <span class=\"title\">KalmanFilter::correct</span><span class=\"params\">(<span class=\"keyword\">const</span> oclMat&amp; measurement)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CV_Assert</span>(measurement.<span class=\"built_in\">empty</span>() == <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">gemm</span>(measurementMatrix, errorCovPre, <span class=\"number\">1</span>, <span class=\"built_in\">oclMat</span>(), <span class=\"number\">0</span>, temp2);  <span class=\"comment\">// tmp2 = H * p&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">gemm</span>(temp2, measurementMatrix, <span class=\"number\">1</span>, measurementNoiseCov, <span class=\"number\">1</span>, temp3, GEMM_2_T);  <span class=\"comment\">// tmp3 = tmp2 * H^T + R = H * p * H^T + R (K的分母)</span></span><br><span class=\"line\">    Mat temp;</span><br><span class=\"line\">    <span class=\"built_in\">solve</span>(<span class=\"built_in\">Mat</span>(temp3), <span class=\"built_in\">Mat</span>(temp2), temp, DECOMP_SVD);  <span class=\"comment\">// tmp = </span></span><br><span class=\"line\">    temp4.<span class=\"built_in\">upload</span>(temp);</span><br><span class=\"line\">    gain = temp4.<span class=\"built_in\">t</span>();</span><br><span class=\"line\">    <span class=\"built_in\">gemm</span>(measurementMatrix, statePre, <span class=\"number\">-1</span>, measurement, <span class=\"number\">1</span>, temp5);</span><br><span class=\"line\">    <span class=\"built_in\">gemm</span>(gain, temp5, <span class=\"number\">1</span>, statePre, <span class=\"number\">1</span>, statePost);</span><br><span class=\"line\">    <span class=\"built_in\">gemm</span>(gain, temp2, <span class=\"number\">-1</span>, errorCovPre, <span class=\"number\">1</span>, errorCovPost);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> statePost;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"参数调整\"><a href=\"#参数调整\" class=\"headerlink\" title=\"参数调整\"></a>参数调整</h2><p><a href=\"https://blog.csdn.net/weixin_45751396/article/details/119595886?ops_request_misc=%7B%22request%5Fid%22%3A%22165656979216782184638870%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165656979216782184638870&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-3-119595886-null-null.142^v26^pc_rank_34,157^v15^new_3&amp;utm_term=卡尔曼滤波+代码实现&amp;spm=1018.2226.3001.4187\">STM32应用(六)一阶卡尔曼滤波代码和简单应用_三木今天学习了嘛的博客-CSDN博客_stm32卡尔曼滤波</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/37750839\">卡尔曼滤波中关键参数的调整 - 知乎 (zhihu.com)</a></p>\n<ul>\n<li><p>过程噪声Q</p>\n<p>Q值为过程噪声，越小系统越容易收敛，我们对模型预测的值信任度越高；但是太小则容易发散，如果Q为零，那么我们只相信预测值；Q值越大我们对于预测的信任度就越低，而对测量值的信任度就变高；如果Q值无穷大，那么我们只信任测量值；</p>\n</li>\n<li><p>测量噪声R</p>\n<p>R值为测量噪声，太小太大都不一定合适。R太大，卡尔曼滤波响应会变慢，因为它对新测量的值的信任度降低；越小系统收敛越快，但过小则容易出现震荡；测试时可以保持陀螺仪不动，记录一段时间内陀螺仪的输出数据，这个数据近似正态分布，按3σ原则，取正态分布的(3σ)^2作为R的初始化值。</p>\n</li>\n</ul>\n<p>测试时可以先将Q从小往大调整，将R从大往小调整；先固定一个值去调整另外一个值，看收敛速度与波形输出。</p>\n<p>参考博客：</p>\n<ul>\n<li><p>卡曼滤波</p>\n<p><a href=\"https://blog.csdn.net/moumde/article/details/107191722?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=卡曼滤波&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-107191722.142\">卡尔曼滤波通俗易懂的解释_moumde的博客-CSDN博客_什么是卡尔曼滤波</a></p>\n<p><a href=\"https://blog.csdn.net/YOULANSHENGMENG/article/details/124929480\">SLAM学习笔记——卡尔曼滤波详解_YOULANSHENGMENG的博客-CSDN博客_卡尔曼滤波</a></p>\n<p><a href=\"https://blog.csdn.net/ReadAir/article/details/107442359?ops_request_misc=%7B%22request%5Fid%22%3A%22165655130216780366582209%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165655130216780366582209&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-107442359-null-null.142^v26^pc_rank_34,157^v15^new_3&amp;utm_term=卡尔曼滤波&amp;spm=1018.2226.3001.4187\">【工程师学算法】工程常用算法（二）—— 卡尔曼滤波(Kalman Filter)_ReadAir的博客-CSDN博客_卡尔曼滤波 知乎</a></p>\n</li>\n<li><p>OpenCV</p>\n<p><a href=\"https://blog.csdn.net/GDFSG/article/details/50904811\">学习OpenCV2——卡尔曼滤波(KalmanFilter)详解_Markala的博客-CSDN博客_kalmanfilter opencv</a></p>\n</li>\n</ul>\n","categories":["算法"],"tags":["卡尔曼滤波"]},{"title":"动态时间规整——DTW算法","url":"/2022/07/01/%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%A7%84%E6%95%B4%E2%80%94%E2%80%94DTW%E7%AE%97%E6%B3%95/","content":"<p>Dynamic Time Warping（DTW）是一种衡量两个时间序列之间相似度的方法。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>考虑如下场景，某个单词的发音音调为1-3-2-4，现有两个说话习惯不同的人，一个喜欢拖长首音，一个喜欢拖长尾音，他们说这个单词时的音调如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081334997.png\" width=\"400\"></p>\n<p>如果想知道两人所说的是否是同一个单词，常用的方法是将两个序列进行相似度比较，也即计算两个特征之间的距离。由于两个序列在同一时间上描述的对象不一定相同，传统的欧式距离等误差较大</p>\n<blockquote>\n<p>欧几里得距离</p>\n<p>=|A(1) - B(1)| + |A(2) - B(2)| + |A(3) - B(3)| + |A(4) - B(4)| + |A(5) - B(5)| + |A(6) - B(6)|</p>\n<p>= 0 + 2 + 1 + 1 + 2 + 0</p>\n<p>= 6</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081335367.png\" width=\"400\"></p>\n<p>但如果将序列的某一点与另一序列的连续多点进行对应（即认为某一对象的描述时间增长），再次计算距离：</p>\n<blockquote>\n<p>DTW距离</p>\n<p>= |A(1) - B(1)| + |A(2) - B(1)| + |A(3) - B(2)| + |A(4) - B(2)| + |A(5) - B(3)| + |A(5) - B(4)| + |A(6) - B(5)| + |A(6) - B(6)|</p>\n<p>= 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0</p>\n<p>= 0</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081337090.png\" width=\"400\"></p>\n<p>这种“可以把序列某个时刻的点跟另一时刻多个<strong>连续时刻</strong>的点相对应”的做法称为”时间规整（TW）“。</p>\n<h2 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h2><p>使用dtw求距离可以描述成从dis(A(1), B(1))开始，每次对A(++i)或B(++i)，一直到dis(A(n), B(n))。考虑将求出A，B各点的距离矩阵，问题即转化为从(1, 1)出发，只能往右和往下，找到一条到达(n, n)的最小花费的路径。很容易考虑到动态规划，状态转移方程为：</p>\n<script type=\"math/tex; mode=display\">\ndis[i][j] = min(dis[i - 1][j], dis[i][j - 1], dis[i - 1][j - 1]) + cost[i][j]</script><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202207081337355.png\" width=\"400\"></p>\n<p>参考博客：</p>\n<p><a href=\"https://blog.csdn.net/qq_36744449/article/details/121472677\">https://blog.csdn.net/qq_36744449/article/details/121472677</a></p>\n","tags":["动态规划","DTW"]},{"title":"时间/空间冗余——帧间预测编码","url":"/2022/05/31/%E7%AC%94%E8%AE%B0/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E2%80%94%E2%80%94%E6%97%B6%E7%A9%BA%E5%86%97%E4%BD%99/","content":"<h1 id=\"帧间预测编码的运动估计\"><a href=\"#帧间预测编码的运动估计\" class=\"headerlink\" title=\"帧间预测编码的运动估计\"></a>帧间预测编码的运动估计</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li><p>运动估计：对两帧图像之间的运动位移进行估计（<strong>只有编码时需要运动估计</strong>）</p>\n</li>\n<li><p>运动补偿：根据估计得到的运动位移对图像进行对齐</p>\n</li>\n<li><p>目的：引入运动估计，就是为了<strong>减少</strong>帧间预测编码<strong>残差图像</strong>所包含的<strong>信息量</strong>，进而达到数据<strong>压缩</strong>的目的</p>\n</li>\n</ul>\n<h2 id=\"基于块的运动估计\"><a href=\"#基于块的运动估计\" class=\"headerlink\" title=\"基于块的运动估计\"></a>基于块的运动估计</h2><ul>\n<li><p>将视频的每一帧分成许多互不重叠的<strong>宏块</strong>（16*16像素图像块）</p>\n</li>\n<li><p>对每个宏块到参考帧某一给定特定搜索范围内根据一定的<strong>匹配准则</strong>找出与当前块<strong>最相似的块</strong>，即<strong>匹配块</strong></p>\n</li>\n<li><p>匹配块与当前块的相对位移即为<strong>运动矢量</strong>，和残差数据均要写入压缩流</p>\n</li>\n</ul>\n<h2 id=\"运动估计的匹配准则\"><a href=\"#运动估计的匹配准则\" class=\"headerlink\" title=\"运动估计的匹配准则\"></a>运动估计的匹配准则</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301948447.png\" width=\"400\"></p>\n<h2 id=\"运动估计算法\"><a href=\"#运动估计算法\" class=\"headerlink\" title=\"运动估计算法\"></a>运动估计算法</h2><ol>\n<li><p>运动估计全搜索算法</p>\n<ul>\n<li><p>按一定的顺序计算出搜索窗口内<strong>所有像素点</strong>的SAD 值，找出SAD最小的点所在的位置作为运动矢量</p>\n</li>\n<li><p>最简单、最原始，能得到<strong>全局最优</strong>结果，但<strong>计算量非常大</strong></p>\n</li>\n</ul>\n</li>\n<li><p>运动估计快速算法</p>\n<ul>\n<li><p>不再搜索窗口内所有像素点，而是通过搜索窗口内<strong>少数像素点</strong>就达到与<strong>全搜索接近</strong>的准确度</p>\n</li>\n<li><p>基本思想：石油勘探时可在各方向分别选择一个点去勘探，看哪个方向油量最多，就在那个方向附近再进一步勘探，其他方向就不再勘探了</p>\n</li>\n<li><p><strong>计算量小，近似全局最优</strong></p>\n</li>\n</ul>\n</li>\n<li><p>三步搜索法</p>\n<ul>\n<li><p>以窗口中心为中心，<strong>步长为4</strong>，进行周围8个点搜索，得到一个最佳匹配点，共搜索了9个点</p>\n</li>\n<li><p>以上一步最佳匹配点为中心，<strong>步长为2</strong>，继续搜索周围8个点得到最佳匹配点，共搜索了8个点</p>\n</li>\n<li><p>同上一步，只是<strong>步长为1</strong>，最后得到的最佳匹配点就是最终匹配点</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205302006099.png\" width=\"200\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"运动估计与块大小\"><a href=\"#运动估计与块大小\" class=\"headerlink\" title=\"运动估计与块大小\"></a>运动估计与块大小</h2><p>通常一个块内可能有多个运动趋势，所以 $16 \\times 16$运动估计的残差信息量很大</p>\n<p>但并不是运动估计的运动估计的基本单元块大小越小对压缩就越好，分块变小后数据量也会增加</p>\n<blockquote>\n<p><strong>分块变小后数据量增加的原因：</strong><br><strong>匹配数量不变，运动矢量数增多</strong></p>\n</blockquote>\n<ul>\n<li><p>如何快速准确的选择运动估计的块大小模式？</p>\n</li>\n<li><p>可用的自适应策略：</p>\n<ul>\n<li><p>先匹配大块，若超出设定值，再进行细分</p>\n</li>\n<li><p>计算方差（即图的平坦/光滑程度），方差小选大块，方差大选小块</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"视频预测编码\"><a href=\"#视频预测编码\" class=\"headerlink\" title=\"视频预测编码\"></a>视频预测编码</h1><h2 id=\"帧间-帧内预测\"><a href=\"#帧间-帧内预测\" class=\"headerlink\" title=\"帧间/帧内预测\"></a>帧间/帧内预测</h2><ul>\n<li><p>帧间预测：预测值是<strong>时间上</strong>相邻的图像像素值，去除的是<strong>时间冗余</strong></p>\n</li>\n<li><p>帧内预测：预测值是<strong>空间上</strong>相邻的图像像素值，去除的是<strong>空间冗余</strong></p>\n</li>\n<li><p>相同点</p>\n<ul>\n<li>编码端：原始值－预测值＝差值</li>\n<li>解码端：差值＋预测值＝原始值</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>帧间预测根据运动趋势估计，需要进行运动估计得到运动矢量</li>\n<li>帧内预测根据纹理方向估计，不需要进行运动估计</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"静止图像的二维预测编码\"><a href=\"#静止图像的二维预测编码\" class=\"headerlink\" title=\"静止图像的二维预测编码\"></a>静止图像的二维预测编码</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311421438.png\" width=\"400\"></p>\n<h2 id=\"视频帧类型\"><a href=\"#视频帧类型\" class=\"headerlink\" title=\"视频帧类型\"></a>视频帧类型</h2><ol>\n<li><p>类型</p>\n<ul>\n<li><p>I帧：不能进行帧间预测，只能进行帧内预测，基本选项（关键帧）</p>\n</li>\n<li><p>P帧：可以进行前向帧间预测，基本选项</p>\n</li>\n<li><p>B帧：可以进行双向帧间预测，高级选项</p>\n</li>\n<li><p>第一帧类型为I帧，其他帧类型由<strong>人工设置参数决定</strong>（视频帧类型是提前设定好的，无法自适应调整）</p>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>I帧不能去除时间冗余，只能去除空间冗余；P帧可以去除时间冗余</p>\n</li>\n<li><p><strong>一般情况下</strong>，：视频帧的时间冗余多于空间冗余，<strong>I帧数据量大于P帧</strong>；特殊情况下，视频帧的时间和空间冗余均较多，I帧P帧数据量均较少</p>\n</li>\n</ul>\n</li>\n<li><p>视频帧类型选择</p>\n<p> 普遍情况下，全P帧数据量小。</p>\n<p> 问题在于：</p>\n<ul>\n<li><p>只能顺序解码</p>\n<p>  <strong>全P帧</strong>会导致视频只能从第一帧开始解码播放，<strong>不能拖动进度条</strong>从后续某一帧开始解码播放。</p>\n<p>  应当<strong>插入I帧</strong>以保证可以<strong>从后续某一帧开始解码播放</strong>。</p>\n</li>\n<li><p>容错率低</p>\n<p>  <strong>全P帧</strong>会导致视频某一帧的<strong>误码会在时域上逐帧扩散</strong>。</p>\n<p>  应当<strong>插入I帧</strong>以保证<strong>误码的时域扩散被终止</strong>。</p>\n</li>\n<li><p>场景切换</p>\n<p>  视频中前一帧与后一帧图像发生了内容切换，时域上相邻的两帧图像之间<strong>没有时间相关性</strong>，几乎无法起到去冗余的效果</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"视频宏块类型\"><a href=\"#视频宏块类型\" class=\"headerlink\" title=\"视频宏块类型\"></a>视频宏块类型</h2><ol>\n<li><p>类型</p>\n<ul>\n<li><p>Intra宏块：进行<strong>帧内预测</strong>的16*16像素图像块</p>\n</li>\n<li><p>Inter宏块：进行<strong>帧间预测</strong>的16*16像素图像块</p>\n</li>\n</ul>\n</li>\n<li><p>帧类型与宏块类型的关系</p>\n<ul>\n<li><p>I帧：<strong>所有</strong>宏块均为<strong>Intra宏块</strong>，不能进行帧间预测，只能进行帧内预测</p>\n</li>\n<li><p>P帧：宏块可以为<strong>Inter宏块</strong>，进行帧间预测，也可以为<strong>Intra宏块</strong>，进行帧内预测</p>\n</li>\n<li><p>P帧中的Intra宏块</p>\n<ul>\n<li>当前帧出现了前一帧未出现的新目标，新目标与前一帧没有时间相关性</li>\n<li>目标连续，但当前帧中目标运动太过剧烈，目标与前一帧时 间相关性太弱</li>\n<li>当前帧内容自身过于简单相似，空间相关性太强</li>\n<li><strong>总结</strong>：P帧中宏块类型的选择是时间相关性（时间冗余）和空间相关性（空间冗余）的比较。时间相关性越强，时间冗余越多，就应该Inter宏块类型；空间相关性越强，空间冗余越多，就应该Intra宏块类型</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","categories":["笔记"],"tags":["多媒体"]},{"title":"字典编码","url":"/2022/05/30/%E7%AC%94%E8%AE%B0/%E5%AD%97%E5%85%B8%E7%BC%96%E7%A0%81/","content":"<h1 id=\"LZ77\"><a href=\"#LZ77\" class=\"headerlink\" title=\"LZ77\"></a>LZ77</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>字典为已编码序列的一部分，即搜索缓冲区</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205300957754.png\" width=\"450\"></p>\n<ol>\n<li><p>机制：滑动窗口</p>\n<ul>\n<li><p>搜索缓冲区(Search buffer)、前向（look ahead）缓冲区、搜索指针(search pointer)</p>\n</li>\n<li><p>在搜索缓冲区中，寻找与搜索指针指向的字符串匹配的最长串，并对其进行编码</p>\n</li>\n</ul>\n</li>\n<li><p>原理</p>\n<p> 如果某些模式在局部重复出现，能得到更有效的表示</p>\n</li>\n</ol>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301036952.png\" width=\"430\"></p>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><ul>\n<li><p>序列；cabracadabrarrarrad</p>\n</li>\n<li><p>|cabraca|<u>d</u>abrar|rarrad</p>\n<blockquote>\n<p>没有匹配的字符，输出<0, 0, c(d)></0,></p>\n</blockquote>\n</li>\n<li><p>c|<u>abra</u>cad|<u>abra</u>rr|rarrad</p>\n<blockquote>\n<7, 4, c(r)>\n</7,></blockquote>\n</li>\n<li><p>cabra|cadab<u>rar|rar</u>rad|</p>\n<blockquote>\n<p><strong>可以跨边界</strong><br>&lt; 3, 5, C(d)&gt;比<3, 3, c(r)>更优</3,></p>\n</blockquote>\n</li>\n<li><p>总结：匹配时有三种情况</p>\n<ul>\n<li>没有匹配</li>\n<li>匹配成功</li>\n<li>匹配串超过了搜索缓冲区</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"解码\"><a href=\"#解码\" class=\"headerlink\" title=\"解码\"></a>解码</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301422091.png\" width=\"330\"></p>\n<h1 id=\"LZ78\"><a href=\"#LZ78\" class=\"headerlink\" title=\"LZ78\"></a>LZ78</h1><h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><ul>\n<li><p>LZ77假设模式满足局部性，字典为隐式</p>\n</li>\n<li><p>LZ78没有搜索缓冲区，使用显式的字典</p>\n</li>\n<li><p>编码器/解码器同步建立字典</p>\n</li>\n</ul>\n<h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>LZ78算法在压缩过程中维护一个动态字典：若当前字符没有匹配，则按以下方式更新字典：<script type=\"math/tex\">字典原有词条+当前没有匹配的字符 -> 字典的新词条</script></p>\n<h2 id=\"输出格式-1\"><a href=\"#输出格式-1\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301431303.png\" width=\"320\"></p>\n<h2 id=\"编码-1\"><a href=\"#编码-1\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301435793.png\" width=\"360\"></p>\n<h2 id=\"解码-1\"><a href=\"#解码-1\" class=\"headerlink\" title=\"解码\"></a>解码</h2><p>根据LZ78编码的特性，解码时需要参照的索引必然在已重建的字典中，故能很容易地重建字典表，解出最初的字符串</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>当编码继续进行，字典也将继续增长。</p>\n<p>解决方法有：</p>\n<ol>\n<li><p>停止增长字典</p>\n<p> 当字典词条增加至一定数量时，停止增长字典。相当于从此成为一个静态字典策略</p>\n</li>\n<li><p>删除一些较早用过的项</p>\n<p> 通过某种判断，例如基于使用统计，删除一些项（但还没有好的算法决定哪些项该删）</p>\n</li>\n<li><p>将字典全部删除，从空开始重建</p>\n</li>\n</ol>\n<h1 id=\"LZW\"><a href=\"#LZW\" class=\"headerlink\" title=\"LZW\"></a>LZW</h1><h2 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h2><ul>\n<li>字典初始化：将单个信源符号按照符号顺序写入字典表</li>\n</ul>\n<p>编码流程类似LZ78，但输出从从二元变为一元形式</p>\n<h2 id=\"编码-2\"><a href=\"#编码-2\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301617869.png\" width=\"450\"></p>\n<h2 id=\"解码-2\"><a href=\"#解码-2\" class=\"headerlink\" title=\"解码\"></a>解码</h2><p>根据输入和初始字典，依次构造原串和完整字典表，大致流程与LZ78相似。</p>\n<h2 id=\"LZW特殊情况\"><a href=\"#LZW特殊情况\" class=\"headerlink\" title=\"LZW特殊情况\"></a>LZW特殊情况</h2><p>在编码和解码地过程中，LZW算法存在一些特殊情况，通常为解码时当前索引指向的字典项还未解出，如下例所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301752907.png\" width=\"300\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301752214.png\" width=\"280\"></p>\n<p>对原字符串第5位进行解码时，索引5的字典项末尾还未推出，但很容易发现第5位是索引5的开头，即可解出索引5的字符</p>\n<h2 id=\"字典结构\"><a href=\"#字典结构\" class=\"headerlink\" title=\"字典结构\"></a>字典结构</h2><ul>\n<li><p>字典越大，能存储更多的字符串，也就能匹配更长的字符串，但其代价是指针更长（标识需要的位数越多），搜索起来也更慢</p>\n</li>\n<li><p>对字典而言，最好的数据结构是树：trie</p>\n</li>\n</ul>\n","categories":["笔记"],"tags":["多媒体","LZ77","LZ78","LZW"]},{"title":"视频图像压缩","url":"/2022/05/28/%E7%AC%94%E8%AE%B0/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/","content":"<h1 id=\"视频图像压缩基础\"><a href=\"#视频图像压缩基础\" class=\"headerlink\" title=\"视频图像压缩基础\"></a>视频图像压缩基础</h1><h2 id=\"人眼视觉特性\"><a href=\"#人眼视觉特性\" class=\"headerlink\" title=\"人眼视觉特性\"></a>人眼视觉特性</h2><ul>\n<li><p>人眼的光谱灵敏度：暗环境下，人眼时候去感觉彩色的能力，仅能辨别白色和灰色</p>\n</li>\n<li><p>视觉的亮度适应性：明适应（暗-&gt;亮）；暗适应（亮-&gt;暗）；人眼能通过调节感光灵敏度来适应范围很广的亮度；人眼对目标亮度的感知更多依赖于目标和背景之间的<strong>亮度差</strong></p>\n</li>\n<li><p>“马赫”带：视觉系统往往会在不同强度区域的边界处出现“下冲”或“上冲”现象</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205100930121.png\" width=\"250\"></p>\n</li>\n<li><p>侧抑制：某个感光细胞受到光线刺激时，若它的相邻感光细胞再受到刺激，则它的反应会减弱</p>\n</li>\n<li><p>几何错觉：眼睛填充了不存在的信息或者错误的感知了物体的几何特点</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205100934897.png\" width=\"400\"></p>\n</li>\n<li><p>视觉关注度</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205281508420.png\" width=\"350\"></p>\n</li>\n</ul>\n<h2 id=\"视频压缩哪些环节考虑了人眼视觉特性\"><a href=\"#视频压缩哪些环节考虑了人眼视觉特性\" class=\"headerlink\" title=\"视频压缩哪些环节考虑了人眼视觉特性\"></a>视频压缩哪些环节考虑了人眼视觉特性</h2><ul>\n<li><p>YCrBr：人眼对亮度更敏感，所以压缩时优先损失色彩</p>\n</li>\n<li><p>量化编码：人眼更关注低频信息，低频信息比高频更重要</p>\n</li>\n<li><p>视频帧率20-30FPS：视觉暂留</p>\n</li>\n<li><p>后滤波处理：对压缩解码后的图像做后滤波处理，使边界平滑</p>\n</li>\n<li><p>视觉关注度：关注区域清晰一些，背景区域模糊一些</p>\n</li>\n<li><p>用假纹理替代水波纹、草地等信息</p>\n</li>\n<li><p>降低分辨率时，优先降低量化分辨率而不是空间分辨率（颜色失真相比图片模糊更能被接受）</p>\n</li>\n<li><p>量化步长</p>\n</li>\n</ul>\n<h2 id=\"色彩模型\"><a href=\"#色彩模型\" class=\"headerlink\" title=\"色彩模型\"></a><a href=\"https://xyzinc-xyx.github.io/2022/04/11/%E7%AC%94%E8%AE%B0/%E8%89%B2%E5%BD%A9%E6%A8%A1%E5%9E%8B/\">色彩模型</a></h2><ul>\n<li><p>RGB</p>\n</li>\n<li><p>HSI</p>\n</li>\n<li><p>YCbCr</p>\n</li>\n</ul>\n<h2 id=\"数据压缩\"><a href=\"#数据压缩\" class=\"headerlink\" title=\"数据压缩\"></a>数据压缩</h2><p><strong>压缩的本质：去冗余</strong></p>\n<ol>\n<li><p>评价指标</p>\n<p> 压缩的评价指标：<strong>压缩比、失真度（有损压缩才存在失真）、计算复杂度</strong></p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205281618774.png\" width=\"380\"></p>\n</li>\n<li><p>标准化</p>\n<p> 对于任何形式的通信来说，只有当信息的<strong>发送方和接受方都能够理解编码机制</strong>的时候压缩数据通信才能够工作。</p>\n<p> 因此数据压缩算法必须<strong>标准化</strong>，制定并遵循技术标准。如图像压缩标准JPEG系列、视频压缩标准MPEG系列等。</p>\n</li>\n</ol>\n<h1 id=\"数据压缩基本方法\"><a href=\"#数据压缩基本方法\" class=\"headerlink\" title=\"数据压缩基本方法\"></a>数据压缩基本方法</h1><h2 id=\"游程编码\"><a href=\"#游程编码\" class=\"headerlink\" title=\"游程编码\"></a>游程编码</h2><ol>\n<li><p>思想</p>\n<p> 如果数据项d在输入流中出现n次，则以单个字符对nd替换n次出现者。这个连续出现的数据项叫做游程n，这种数据压缩方法称为游程编码或RLE。</p>\n<blockquote>\n<p>eg. all is too well -&gt; a2l is t2o we2l<br>如何区分原字符串中的数字？在重复部分前缀一个特殊的提示字符<br>a@2l is t@2o we@2l</p>\n</blockquote>\n</li>\n<li><p>压缩比</p>\n<p> 假设待压缩字符串长度为N，字符串中包含M次重复，每次重复的平均长度为L。M次中的每一次重复可用3字节代替，因此，压缩后字符串的长度为N-M(L-3)，压缩因子为</p>\n<script type=\"math/tex; mode=display\">\nN/(N-M(L-3))</script></li>\n<li><p>适用场景</p>\n<p> RLE图像压缩基于这样的事实：如果我们在该图像中随机选择一个像素，其相邻像素色彩相同的可能性很大，因此压缩器逐行扫描位图，搜索色彩相同像素的游程。</p>\n<blockquote>\n<p>二值、灰度、彩色图像中，采用游程编码压缩效率最高的是：<strong>二值</strong></p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"熵编码-统计编码\"><a href=\"#熵编码-统计编码\" class=\"headerlink\" title=\"熵编码/统计编码\"></a>熵编码/统计编码</h2><h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><ol>\n<li><p>熵：信息的度量</p>\n</li>\n<li><p>变长码：不同于等长编码，变长编码通过可变的字节数表示不同的字符。</p>\n<blockquote>\n<p>变长码遵循的规则</p>\n<ul>\n<li>把短码赋给出现频率高的字符；</li>\n<li>遵循前缀性</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"香农-费诺编码\"><a href=\"#香农-费诺编码\" class=\"headerlink\" title=\"香农-费诺编码\"></a>香农-费诺编码</h3><ol>\n<li>按概率把符号从大到小排序</li>\n<li>将这些符号划分成概率几乎相同的两个子集</li>\n<li>一个子集以０开始，另一个以１开始</li>\n<li><p>再按照同样的步骤划分这两个子集，一直到子集不能被划分</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205281724425.png\" width=\"430\"></p>\n</li>\n</ol>\n<h3 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h3><ol>\n<li><p>步骤</p>\n<ul>\n<li>信源符号按概率分布大小，以递减次序排列；</li>\n<li>取两个<strong>最小的概率</strong>，分别赋以“0”,“1”；然后把这两个概率值相加，作为新概率值与其他概率重新排序</li>\n<li>按重排概率值，重复上述操作，直到概率和为1</li>\n<li><p>由后向前排列码序，即得到哈夫曼编码</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205291934229.png\" width=\"430\"></p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205291934667.png\" width=\"380\"></p>\n</li>\n<li><p>由于哈夫曼编码码长不等，存在一个输入与输出的速率匹配问题。解决的办法是设置一定容量的缓冲寄存器。<strong>码方差越小，速率匹配的难度越低。</strong></p>\n</li>\n</ul>\n</li>\n<li><p>合并方法的比较</p>\n<p> 由上图可知哈夫曼编码过程编出的最佳码不是唯一的，但其平均码长是一样的，其中<strong>码方差最小者最佳</strong>。因此在哈夫曼编码过程中，合并后的新符号应当排在其它相同概率符号的上面。（码方差小，编码机会更均等，数据波动少）</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205291949004.png\" width=\"430\"></p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205291949562.png\" width=\"210\"></p>\n</li>\n<li><p>码长的波动实质上是<strong>编码机会</strong>的波动</p>\n</li>\n<li><p>解码</p>\n<p> 哈夫曼解码：哈夫曼树叶子节点的搜索</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205291955627.png\" width=\"400\"></p>\n</li>\n<li><p>N进制哈夫曼编码</p>\n<p> 和二进制思路基本相同，需要注意的有：</p>\n<ul>\n<li>每次取最小的$n$个概率，赋为0, 1, …, n -1</li>\n<li><p>信源符号个数$r$需满足$r=(n-1)k+n$，不足时补充对应数量的概率为0的符号</p>\n<p>eg.四元哈夫曼编码：<br><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205292002644.png\" width=\"500\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"算数编码\"><a href=\"#算数编码\" class=\"headerlink\" title=\"算数编码\"></a>算数编码</h3><ol>\n<li><p>思想</p>\n<p> Huffman编码中<strong>每个符号</strong>都用整数个bits来表示，影响编码效率。</p>\n<p> 若能把<strong>一串符号</strong>作为编码单位，则效率还可提高。</p>\n<p> 待编码的符号串可以映射成为[0, 1)中唯一的一个区间</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205292020682.png\" width=\"470\"></p>\n</li>\n<li><p>编码过程</p>\n<ul>\n<li>首先定义两个变量：<script type=\"math/tex\">Low=0, High=1</script></li>\n<li><p>当读入和处理信源符号A时，更新Low，High：</p>\n<script type=\"math/tex; mode=display\">NewHigh = OldLow + Range \\times HighRange(A)</script><script type=\"math/tex; mode=display\">NewLow = OldLow + Range \\times LowRange(A)</script><p>其中，$Range=OldHigh-OldLow$，$LowRange(A), HighRange(A)$分别表示A对应区域的上下限。</p>\n</li>\n<li><p>注：若题目没有告知全局概率，用局部概率替代</p>\n</li>\n</ul>\n</li>\n<li><p>解码</p>\n<ul>\n<li><p>根据符号即其区间，重构概率和频率表</p>\n</li>\n<li><p>根据编码结果$code$所在的区间，可以判断第一个符号所在的区间$s$</p>\n</li>\n<li><p>更新$code$，<script type=\"math/tex\">code = \\frac{code - LowRange(s)}{Range(s)}</script>，以消除符号$s$对码字的影响</p>\n</li>\n<li><p>重复以上操作直至结束</p>\n</li>\n</ul>\n</li>\n<li><p>算术解码结束的判定</p>\n<p> 若以某值（LowRange/HighRange等）为解码结束条件，当输入流中最后一个符号恰好为此值时，会出现还未对其解码就提前结束的情况。</p>\n<p> 正确的解决方法是加入eof等符号，并把它以很小的概率加入到概率表中,编码时,把它作为最后一个字符编码到输入流中,当解码时,解码出eof认为解码过程结束</p>\n</li>\n</ol>\n<h2 id=\"字典编码\"><a href=\"#字典编码\" class=\"headerlink\" title=\"字典编码\"></a>字典编码</h2><p>此前的编码方法中，大多假设符号是独立的，但实际中许多常见的数据类型并非如此，例如：文本、图像和源代码文件等。</p>\n<ol>\n<li><p>思想</p>\n<ul>\n<li><p>字典编码的思路：根据数据本身包含有重复代码的特性</p>\n</li>\n<li><p>标识经常出现的符号模式 —— 保存于字典中</p>\n</li>\n<li><p>对这些常出现的模式采用更有效的编码方式 —— 用其在字典中的索引作为码字；而对其它部分采用缺省（不太有效）的编码方式。以期总的编码效率更高</p>\n</li>\n<li><p>显然，<strong>字典编码的高效率对于有规律信源（例如文本）较为合理，而对随机数据无效</strong></p>\n</li>\n</ul>\n</li>\n<li><p>静态字典</p>\n<p> 静态字典适用于对信源的结构有足够的先验知识时，利用先验知识构造字典。</p>\n<p> 对对针对其设计的特定应用和数据有效。（例如电话号码的区号、学校的学生信息表等）</p>\n</li>\n<li><p>自适应字典</p>\n<p> 许多情况下事先不知道待编码数据的统计特性，无法预先构造静态字典。</p>\n<p> 自适应字典可以根据待编码数据动态地形成字典，常见的自适应字典编码有：</p>\n<ul>\n<li><p><a href=\"https://xyzinc-xyx.github.io/2022/05/30/%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E5%AD%97%E5%85%B8%E7%BC%96%E7%A0%81/\">字典编码</a></p>\n<ul>\n<li><p>LZ77</p>\n</li>\n<li><p>LZ78</p>\n</li>\n<li><p>LZW</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"视频图像压缩方法\"><a href=\"#视频图像压缩方法\" class=\"headerlink\" title=\"视频图像压缩方法\"></a>视频图像压缩方法</h1><h2 id=\"视频压缩的可行性\"><a href=\"#视频压缩的可行性\" class=\"headerlink\" title=\"视频压缩的可行性\"></a>视频压缩的可行性</h2><ul>\n<li><p>视频压缩的基本依据</p>\n<ul>\n<li>空间冗余</li>\n<li>频率冗余</li>\n<li>视觉冗余</li>\n<li>熵冗余</li>\n<li>时间冗余</li>\n</ul>\n</li>\n<li><p>视频压缩的基本方法</p>\n<ul>\n<li>帧内预测编码</li>\n<li>变换编码</li>\n<li>量化编码</li>\n<li>熵编码</li>\n<li><p>帧间预测编码</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205301940400.png\" width=\"420\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"时间-空间冗余——帧间预测编码\"><a href=\"#时间-空间冗余——帧间预测编码\" class=\"headerlink\" title=\"时间/空间冗余——帧间预测编码\"></a><a href>时间/空间冗余——帧间预测编码</a></h2><p>时间上视频信息的相似性、相关性称为时间冗余</p>\n<h2 id=\"频率冗余——变换编码\"><a href=\"#频率冗余——变换编码\" class=\"headerlink\" title=\"频率冗余——变换编码\"></a>频率冗余——变换编码</h2><p>在空间域中，能量倾向于均匀地分布；而在频率域中，能量集中到少数几个“重要”的数据上<br><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311056824.png\" width=\"400\"></p>\n<h3 id=\"傅里叶变换\"><a href=\"#傅里叶变换\" class=\"headerlink\" title=\"傅里叶变换\"></a>傅里叶变换</h3><p>任何周期函数都可以表示为不同频率的正弦或余弦的加权和的形式</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311114485.png\" width=\"480\"></p>\n<h3 id=\"基图像\"><a href=\"#基图像\" class=\"headerlink\" title=\"基图像\"></a>基图像</h3><ul>\n<li><p>DCT （Discrete Cosine Transform）变换，即离散余弦变换。在目前的多数图像和视频压缩标准中都用到了DCT技术。</p>\n</li>\n<li><p>DCT变换特点：</p>\n<p>  （1）无虚数部分；</p>\n<p>  （2）正反变换核一样</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311117773.png\" width=\"250\"></p>\n<p>竖条纹表示竖方向上频率为0</p>\n<h3 id=\"空域与频域图像\"><a href=\"#空域与频域图像\" class=\"headerlink\" title=\"空域与频域图像\"></a>空域与频域图像</h3><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311119110.png\" width=\"450\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311119315.png\" width=\"450\"></p>\n<h3 id=\"变换编码\"><a href=\"#变换编码\" class=\"headerlink\" title=\"变换编码\"></a>变换编码</h3><ul>\n<li><p>能够实现对能量的压缩，将能量集中到少数几个“重要”的数据上</p>\n</li>\n<li><p>低频（基本信息）权重系数大</p>\n</li>\n<li><p>高频（细节信息）权重系数小</p>\n</li>\n<li><p>变换的基本单元：8×8 像素块</p>\n</li>\n</ul>\n<h2 id=\"视觉冗余——量化编码\"><a href=\"#视觉冗余——量化编码\" class=\"headerlink\" title=\"视觉冗余——量化编码\"></a>视觉冗余——量化编码</h2><p>视觉系统是非均匀和非线性的，对不同的变化感知程度不同。<strong>对低频信息（基本信息）感知程度较强；对高频信息（细节信息）感知程度较弱</strong></p>\n<p>频域低通滤波——平滑；频域高通滤波——锐化</p>\n<h3 id=\"量化编码\"><a href=\"#量化编码\" class=\"headerlink\" title=\"量化编码\"></a>量化编码</h3><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311124307.png\" width=\"500\"></p>\n<h3 id=\"DCT编码失真\"><a href=\"#DCT编码失真\" class=\"headerlink\" title=\"DCT编码失真\"></a>DCT编码失真</h3><p>DCT 本身没有失真，是可逆变换，如果计算精度保证的话，变换前后的结果是一样的。</p>\n<ul>\n<li><p>基于DCT 变换的分块量化导致失真：</p>\n<ul>\n<li><p>块效应：变换编码是一种块结构编码方法，易出现块与块间的不连续性。</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311126439.png\" width=\"350\"></p>\n</li>\n<li><p>蚊式噪声：看起来像某种围绕物体与背景之间高频分界(在前景物体与背景之间形成的尖锐跳变)的朦胧的东西或闪光体。</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311127743.png\" width=\"300\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"视频压缩\"><a href=\"#视频压缩\" class=\"headerlink\" title=\"视频压缩\"></a>视频压缩</h1><h2 id=\"视频压缩流程\"><a href=\"#视频压缩流程\" class=\"headerlink\" title=\"视频压缩流程\"></a>视频压缩流程</h2><blockquote>\n<p>帧差图像为什么要通过正反DCT变换、量化和反量化过程，而不是直接传过来？<br>因为解码端得不到无损的原始帧，只能得到有损的图像；编码端要跟解码端保持一致</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311522292.png\" width=\"900\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311526441.png\" width=\"900\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311528563.png\" width=\"900\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311530513.png\" width=\"450\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311549246.png\" width=\"900\"></p>\n<h2 id=\"视频解压缩流程\"><a href=\"#视频解压缩流程\" class=\"headerlink\" title=\"视频解压缩流程\"></a>视频解压缩流程</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311552163.png\" width=\"900\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311554801.png\" width=\"900\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311555984.png\" width=\"450\"></p>\n<h2 id=\"视频码流结构\"><a href=\"#视频码流结构\" class=\"headerlink\" title=\"视频码流结构\"></a>视频码流结构</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205311558380.png\" width=\"900\"></p>\n<h1 id=\"视频图像编码标准\"><a href=\"#视频图像编码标准\" class=\"headerlink\" title=\"视频图像编码标准\"></a>视频图像编码标准</h1>","categories":["笔记"],"tags":["多媒体"]},{"title":"leetcode刷题记录","url":"/2022/04/22/leetcode%E5%88%B7%E9%A2%98/","content":"<h3 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h3><ol>\n<li><p><a href=\"https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\">剑指 Offer 09. 用两个栈实现队列</a></p>\n<p> 【题解】</p>\n<p> 两个栈相互倒一倒</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CQueue</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    stack&lt;<span class=\"keyword\">int</span>&gt; s1, s2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CQueue</span>() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">appendTail</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        s1.<span class=\"built_in\">push</span>(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s1.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!s1.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = s1.<span class=\"built_in\">top</span>(); s1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            s2.<span class=\"built_in\">push</span>(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = s2.<span class=\"built_in\">top</span>(); s2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!s2.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = s2.<span class=\"built_in\">top</span>(); s2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            s1.<span class=\"built_in\">push</span>(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/\">剑指 Offer 30. 包含min函数的栈</a></p>\n<p> 【题解】</p>\n<p> 很容易想到记录最小值，但用单个变量记录会出现最小值被pop()掉的情况，考虑一个能O(1)取出最小值且保留次小值（按顺序依次变小）的方法。</p>\n<p> 可以想到以初始值为标准，依次判断，若有比它小的数就记录下来，并更新标准。取数的时候，只有栈顶刚好是最小值的时候才将此数删除，所以不可能存在最小值序列比数据栈更早清空的情况。由于只有在末尾增加或删除的操作，故最小值序列也使用栈存储。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    stack&lt;<span class=\"keyword\">int</span>&gt; s, smin;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">MinStack</span>() &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        s.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(smin.<span class=\"built_in\">empty</span>() || x &lt;= smin.<span class=\"built_in\">top</span>()) smin.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.<span class=\"built_in\">top</span>() == smin.<span class=\"built_in\">top</span>()) smin.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> smin.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\">剑指 Offer 06. 从尾到头打印链表</a></p>\n<p> 【题解】</p>\n<p> swap翻转一下，或者拿个栈存、递归都行</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">reversePrint</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; val;</span><br><span class=\"line\">        <span class=\"comment\">// 正常读出来</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            val.<span class=\"built_in\">push_back</span>(head -&gt; val);</span><br><span class=\"line\">            head = head -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 翻转</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sz = val.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sz/<span class=\"number\">2</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(val[i], val[sz - i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/\">剑指 Offer 24. 反转链表</a></p>\n<p> 【题解】</p>\n<p> 先顺序读取val，再顺着链表修改val。或者修改指针指向，反转链表</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; val;</span><br><span class=\"line\">        ListNode* pos = head;</span><br><span class=\"line\">        <span class=\"comment\">// 顺序读取val</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pos != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            val.<span class=\"built_in\">push_back</span>(pos -&gt; val);</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 顺着链表修改val</span></span><br><span class=\"line\">        pos = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = val.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pos -&gt; val = val[i];</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/\">剑指 Offer 35. 复杂链表的复制</a></p>\n<p> 【题解】</p>\n<p> 复制时的难点在于，random指向的节点当前可能并未创建，考虑先将链表顺序复制，再添加random指针。问题转化为如何将random记录下来：由于链表节点均是唯一的，考虑将原链表节点与新链表节点按顺序一一对应，即可通过原random找到新random</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">copyRandomList</span><span class=\"params\">(Node* head)</span> </span>&#123;</span><br><span class=\"line\">        Node *pos = head, *tmp = <span class=\"literal\">NULL</span>, *last = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 考虑将原链表元素和新链表元素一一对应，即可通过原random找到新random</span></span><br><span class=\"line\">        map&lt;Node*, Node*&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pos != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建新节点</span></span><br><span class=\"line\">            tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(pos -&gt; val);</span><br><span class=\"line\">            <span class=\"comment\">// 进行映射</span></span><br><span class=\"line\">            mp[pos] = tmp;</span><br><span class=\"line\">            <span class=\"comment\">// 对新链表进行挂链</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(last != <span class=\"literal\">NULL</span>) last -&gt; next = tmp;</span><br><span class=\"line\">            last = tmp;</span><br><span class=\"line\">            <span class=\"comment\">// 移动pos</span></span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pos = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pos != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据原链表random更新新链表random</span></span><br><span class=\"line\">            mp[pos] -&gt; random = mp[pos -&gt; random];</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mp[head];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/ti-huan-kong-ge-lcof/\">剑指 Offer 05. 替换空格</a></p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">replaceSpace</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        string t = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">length</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27; &#x27;</span>) t += <span class=\"string\">&quot;%20&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> t += s[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\">剑指 Offer 58 - II. 左旋转字符串</a></p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reverseLeftWords</span><span class=\"params\">(string s, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        string t = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n; i &lt; len; i++) t += s[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) t += s[i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"查找算法（简单）\"><a href=\"#查找算法（简单）\" class=\"headerlink\" title=\"查找算法（简单）\"></a>查找算法（简单）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\">剑指 Offer 03. 数组中重复的数字</a></p>\n<p> 【题解】</p>\n<p> 类似桶排的思想，拿值做个标记</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findRepeatNumber</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> f[<span class=\"number\">100000</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!f[nums[i]]) f[nums[i]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/\">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></p>\n<p> 【题解】</p>\n<p> 数组已经排序好了，数完相同的直接返回即可。没排序也是一样的做法，就是没有提前返回。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>(), tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] != target)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tot) <span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> tot++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/\">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></p>\n<p> 【题解】</p>\n<p> 可以把数组扫一遍打上标记，没有标记过的数字即不存在。但考虑到每个数字只出现一次，且仅有一个不出现，所以直接求和，减去所有出现的数，所得即为缺失。可以节省空间。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>(), sum = n * (n + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) sum -= nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"查找算法（中等）\"><a href=\"#查找算法（中等）\" class=\"headerlink\" title=\"查找算法（中等）\"></a>查找算法（中等）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\">剑指 Offer 04. 二维数组中的查找</a></p>\n<p> 【题解】</p>\n<p> 考虑只有一维的情况：由于元素从左到右递增，二分查找是否存在target。<br> 增加行数后，先对第一行进行二分，找到大于target的最小数，以样例为例，即第三个数“7”。由于在二维数组中，元素从上到下也递增，那么大于target必然不在“7”右下方的矩阵中。在下一行中，便可以更新终止位置，重新二分，直到找到为止。</p>\n<blockquote>\n<p><strong>为什么在二分时找大于target的位置挪动r，而不是找小于target的位置挪动l？</strong></p>\n<p>对于第i行小于target的最大数m[i][j]，由于数组从上到下递增，很有可能i+1行中j列以前的数大于m[i][j]，例如样例3，4行。所以不能推导出下一行的起始位置从j开始。挪动l是错误的。</p>\n</blockquote>\n<p> ps. vector使用lower_bound()和数组写法有区别，要注意</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findNumberIn2DArray</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = matrix.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!n) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 样例存在空数组的情况！！！坑了好久才发现QAQ</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ed = m; <span class=\"comment\">// 二分终止位置初值为m</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n &amp;&amp; ed &gt;= <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pos = <span class=\"built_in\">lower_bound</span>(matrix[i].<span class=\"built_in\">begin</span>(), matrix[i].<span class=\"built_in\">begin</span>() + ed, target) - matrix[i].<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos == ed) <span class=\"keyword\">continue</span>; <span class=\"comment\">//所有元素均小于target，直接进入下一行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[i][pos] == target) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">//找到target</span></span><br><span class=\"line\">            ed = pos; <span class=\"comment\">//更新下一行的二分起始位置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\">剑指 Offer 11. 旋转数组的最小数字</a></p>\n<p> 【题解】</p>\n<p> 扫一遍</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = numbers.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(numbers[i] &gt; numbers[i + <span class=\"number\">1</span>]) <span class=\"keyword\">return</span> numbers[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\">剑指 Offer 50. 第一个只出现一次的字符</a></p>\n<p> 【题解】</p>\n<p> 扫两遍，第一遍记次数，第二遍查找</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num[<span class=\"number\">260</span>] = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// 标记出现次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; l; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            num[s[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; l; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num[s[i]] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> s[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> sp = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sp; <span class=\"comment\">// 没有的话返回空格</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"搜索与回溯算法（简单）\"><a href=\"#搜索与回溯算法（简单）\" class=\"headerlink\" title=\"搜索与回溯算法（简单）\"></a>搜索与回溯算法（简单）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/\">剑指 Offer 32 - I. 从上到下打印二叉树</a></p>\n<p> 【题解】</p>\n<p> bfs</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">levelOrder</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode* tmp = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"literal\">NULL</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(tmp -&gt; val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp -&gt; left != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(tmp -&gt; left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp -&gt; right != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(tmp -&gt; right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></p>\n<p> 【题解】</p>\n<p> bfs，加个层数的标记</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        TreeNode* t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> step; <span class=\"comment\">// 记录层数</span></span><br><span class=\"line\">        <span class=\"built_in\">node</span>(TreeNode* tt = <span class=\"literal\">NULL</span>, <span class=\"keyword\">int</span> stp = <span class=\"number\">0</span>) &#123;t = tt; step = stp;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        queue&lt;node&gt; q;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt; &gt; ans;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; cnt;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(root, <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sp = <span class=\"number\">1</span>; <span class=\"comment\">// 记录当前层数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            node tmp = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.t == <span class=\"literal\">NULL</span>) <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.step &gt; sp) <span class=\"comment\">// 换层了</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sp++;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(cnt);</span><br><span class=\"line\">                cnt.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cnt.<span class=\"built_in\">push_back</span>(tmp.t -&gt; val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.t -&gt; left != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(tmp.t -&gt; left, tmp.step + <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.t -&gt; right != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(tmp.t -&gt; right, tmp.step + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root != <span class=\"literal\">NULL</span>) ans.<span class=\"built_in\">push_back</span>(cnt); <span class=\"comment\">// 判断是否初始就为空树，添加最后一层的信息</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></p>\n<p> 【题解】</p>\n<p> 在上题基础上，根据层数奇偶继续翻转</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        TreeNode* t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> step;</span><br><span class=\"line\">        <span class=\"built_in\">node</span>(TreeNode* tt = <span class=\"literal\">NULL</span>, <span class=\"keyword\">int</span> sp = <span class=\"number\">0</span>) &#123;t = tt; step = sp;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        queue&lt;node&gt; q;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt; &gt; ans;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; cnt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(root, <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sp = <span class=\"number\">1</span>; <span class=\"comment\">// 记录当前层数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            node tmp = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>(); </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.step != sp)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(sp %<span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"comment\">// 从右向左打印</span></span><br><span class=\"line\">                    <span class=\"built_in\">reverse</span>(cnt.<span class=\"built_in\">begin</span>(), cnt.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(cnt);</span><br><span class=\"line\">                sp++;</span><br><span class=\"line\">                cnt.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cnt.<span class=\"built_in\">push_back</span>(tmp.t -&gt; val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.t -&gt; left != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(tmp.t -&gt; left, tmp.step + <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.t -&gt; right != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(tmp.t -&gt; right, tmp.step + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sp %<span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"built_in\">reverse</span>(cnt.<span class=\"built_in\">begin</span>(), cnt.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 最后一层别忘记翻转</span></span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(cnt);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"搜索与回溯算法（简单）-1\"><a href=\"#搜索与回溯算法（简单）-1\" class=\"headerlink\" title=\"搜索与回溯算法（简单）\"></a>搜索与回溯算法（简单）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/\">剑指 Offer 26. 树的子结构</a></p>\n<p> 【题解】</p>\n<p> 在A中顺着查找是否能和B完全匹配</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(TreeNode* x, TreeNode* y)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// B可以为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// A不可以</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x -&gt; val != y -&gt; val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> suc = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        suc &amp;= <span class=\"built_in\">check</span>(x -&gt; left, y -&gt; left);</span><br><span class=\"line\">        suc &amp;= <span class=\"built_in\">check</span>(x -&gt; right, y -&gt; right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> suc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSubStructure</span><span class=\"params\">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(B == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(A);</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> suc = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode* t = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t -&gt; val == B -&gt; val)</span><br><span class=\"line\">                suc = <span class=\"built_in\">check</span>(t, B);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(suc) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t -&gt; left != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(t -&gt; left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t -&gt; right != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(t -&gt; right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> suc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/\">剑指 Offer 27. 二叉树的镜像</a></p>\n<p> 【题解】</p>\n<p> 遍历一遍，交换左右子树</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TreeNode* t = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t == <span class=\"literal\">NULL</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(t -&gt; left, t -&gt; right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t -&gt; left != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(t -&gt; left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t -&gt; right != <span class=\"literal\">NULL</span>) q.<span class=\"built_in\">push</span>(t -&gt; right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/\">剑指 Offer 28. 对称的二叉树</a></p>\n<p> 【题解】</p>\n<p> 如果一棵二叉树是对称的，对于任意一层，正反遍历得到的结果应该是一样的。为避免错位情况，给空节点赋一个不存在的值</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> inf = <span class=\"number\">1e7</span> + <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        TreeNode* t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> step;</span><br><span class=\"line\">        <span class=\"built_in\">node</span>(TreeNode* tt = <span class=\"literal\">NULL</span>, <span class=\"keyword\">int</span> sp = <span class=\"number\">0</span>) &#123;t = tt; step = sp;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        queue&lt;node&gt; q;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(root, <span class=\"number\">1</span>));</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; cnt;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sp = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            node tmp = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.step != sp)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sp++;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> sz = cnt.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sz/<span class=\"number\">2</span>; i++) <span class=\"keyword\">if</span>(cnt[i] != cnt[sz - i - <span class=\"number\">1</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                cnt.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.t == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cnt.<span class=\"built_in\">push_back</span>(-inf); <span class=\"comment\">// 为空节点赋一个不存在的值</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cnt.<span class=\"built_in\">push_back</span>(tmp.t -&gt; val);</span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(tmp.t -&gt; left, tmp.step + <span class=\"number\">1</span>)); <span class=\"comment\">// left/right为空不影响</span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(<span class=\"built_in\">node</span>(tmp.t -&gt; right, tmp.step + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sz = cnt.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sz/<span class=\"number\">2</span>; i++) <span class=\"keyword\">if</span>(cnt[i] != cnt[sz - i - <span class=\"number\">1</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 不要漏掉最后一行</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"动态规划（简单）\"><a href=\"#动态规划（简单）\" class=\"headerlink\" title=\"动态规划（简单）\"></a>动态规划（简单）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/\">剑指 Offer 10- I. 斐波那契数列</a></p>\n<p> 【题解】</p>\n<p> 递推</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f[<span class=\"number\">105</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Solution</span>() <span class=\"comment\">// 类的初始化</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        f[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= <span class=\"number\">100</span>; i++) f[i] = (f[i - <span class=\"number\">1</span>] + f[i - <span class=\"number\">2</span>]) % mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/\">剑指 Offer 10- II. 青蛙跳台阶问题</a></p>\n<p> 【题解】</p>\n<p> f[i] = f[i - 1] + f[i - 2]</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f[<span class=\"number\">105</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Solution</span>()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        f[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= <span class=\"number\">100</span>; i++) f[i] = (f[i - <span class=\"number\">1</span>] + f[i - <span class=\"number\">2</span>]) % mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numWays</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/\">剑指 Offer 63. 股票的最大利润</a></p>\n<p> 【题解】</p>\n<p> 扫一遍，记录出现过的最小值，用最小值买进当前值卖出，ans取max</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sz = prices.<span class=\"built_in\">size</span>(); </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sz == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>, mn = prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; sz; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, prices[i] - mn);</span><br><span class=\"line\">            mn = <span class=\"built_in\">min</span>(mn, prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"动态规划（中等）\"><a href=\"#动态规划（中等）\" class=\"headerlink\" title=\"动态规划（中等）\"></a>动态规划（中等）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/\">剑指 Offer 42. 连续子数组的最大和</a></p>\n<p> 【题解】</p>\n<p> 记录前缀和，维护前i位的最小前缀和作为起始位置，枚举截止位置。注意存在负数，答案初值要赋为极小值</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> inf = <span class=\"number\">1e9</span> +<span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum[N]; <span class=\"comment\">// sum[i]表示前i个数的前缀和</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mn[N];  <span class=\"comment\">// mn[i]表示前i个前缀和中最小的</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sz = nums.<span class=\"built_in\">size</span>(), ans = -inf;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sz == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= sz; i++) <span class=\"comment\">// num是从0开始的，注意错位</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum[i] = sum[i - <span class=\"number\">1</span>] + nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            mn[i] = <span class=\"built_in\">min</span>(mn[i - <span class=\"number\">1</span>], sum[i]);</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, sum[i] - mn[i - <span class=\"number\">1</span>]); <span class=\"comment\">// 注意这里是减的是mn[i-1]，不能包含当前位的前缀和，否则当序列全为负数时，会一个都不选</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/\">剑指 Offer 47. 礼物的最大价值</a></p>\n<p> 【题解】</p>\n<p> f[i][j] = max(f[i - 1][j], f[i][j - 1]) + grid[i - 1][j - 1];</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxValue</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f[<span class=\"number\">205</span>][<span class=\"number\">205</span>]; <span class=\"comment\">// f[i][j]记录到达(i, j)的最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = grid.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                f[i][j] = <span class=\"built_in\">max</span>(f[i - <span class=\"number\">1</span>][j], f[i][j - <span class=\"number\">1</span>]) + grid[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]; <span class=\"comment\">//注意grid从零开始，需要错位</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"动态规划（中等）-1\"><a href=\"#动态规划（中等）-1\" class=\"headerlink\" title=\"动态规划（中等）\"></a>动态规划（中等）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/\">剑指 Offer 46. 把数字翻译成字符串</a></p>\n<p> 【题解】</p>\n<p> f[i]表示前i位的方法数，f[i] = f[i - 1] + f[i - 2]（如果i-2~i这两位是25以内的数）</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">translateNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nm[<span class=\"number\">20</span>] = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// 记录num</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            nm[++nm[<span class=\"number\">0</span>]] = num % <span class=\"number\">10</span>;</span><br><span class=\"line\">            num /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f[<span class=\"number\">20</span>]; <span class=\"comment\">// f[i]记录前i位的翻译方法数</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于num是倒着存的，懒得改，所以这里dp也倒着来</span></span><br><span class=\"line\">        f[nm[<span class=\"number\">0</span>] + <span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nm[<span class=\"number\">0</span>]; i &gt;= <span class=\"number\">1</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[i] = f[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = nm[i + <span class=\"number\">1</span>] * <span class=\"number\">10</span> + nm[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x &gt;= <span class=\"number\">10</span> &amp;&amp; x &lt;= <span class=\"number\">25</span>) f[i] += f[i + <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/\">剑指 Offer 48. 最长不含重复字符的子字符串</a></p>\n<p> 【题解】</p>\n<p> 记录每一位字符上一个相同字符的位置，也即保证当前字符不重复不能超过的最前初始位置。顺着扫一遍，得到以当前字符为结尾全没有重复的不能超过的最前初始位置。</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"keyword\">char</span>,<span class=\"keyword\">int</span>&gt; mp; <span class=\"comment\">// 记录每个字符出现的位置</span></span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; last; <span class=\"comment\">// last[i]表示第i位的字符，上一个相同字符的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> startpos = <span class=\"number\">-1</span>;   <span class=\"comment\">// startpos表示以当前字符为结尾，不能超过的最前初始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;    <span class=\"comment\">// ans记录答案</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">length</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(s[i]) != mp.<span class=\"built_in\">end</span>()) last.<span class=\"built_in\">push_back</span>(mp[s[i]]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> last.<span class=\"built_in\">push_back</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">            mp[s[i]] = i;</span><br><span class=\"line\">            startpos = <span class=\"built_in\">max</span>(startpos, last[i]);</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i - startpos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"双指针（简单）\"><a href=\"#双指针（简单）\" class=\"headerlink\" title=\"双指针（简单）\"></a>双指针（简单）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/\">剑指 Offer 18. 删除链表的节点</a></p>\n<p> 【题解】</p>\n<p> 删除节点pos -&gt; next: pos -&gt; next = pos -&gt; next -&gt; next</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteNode</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head -&gt; val == val) <span class=\"keyword\">return</span> head -&gt; next;</span><br><span class=\"line\">        ListNode* pos = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pos -&gt; next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos -&gt; next -&gt; val == val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pos -&gt; next = pos -&gt; next -&gt; next;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\">剑指 Offer 22. 链表中倒数第k个节点</a></p>\n<p> 【题解】</p>\n<p> 先扫一遍，得到链表长度，将倒数第k个节点转化为正数len - k + 1个节点。扫第二遍，删除</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">getKthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode* pos = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pos != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tot++;</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = tot - k + <span class=\"number\">1</span>;    <span class=\"comment\">// 返回正数第r个数</span></span><br><span class=\"line\">        pos = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            r--;</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"双指针（简单）-1\"><a href=\"#双指针（简单）-1\" class=\"headerlink\" title=\"双指针（简单）\"></a>双指针（简单）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/\">剑指 Offer 25. 合并两个排序的链表</a></p>\n<p> 【题解】</p>\n<p> 双指针，同时遍历两个链表，比较大小重新挂链</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* head = <span class=\"literal\">NULL</span>, *pos = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        ListNode *p1 = l1, *p2 = l2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1 != <span class=\"literal\">NULL</span> &amp;&amp; p2 != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p1 -&gt; val &lt; p2 -&gt; val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                    head = pos = p1;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    pos -&gt; next = p1;</span><br><span class=\"line\">                    pos = pos -&gt; next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p1 = p1 -&gt; next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                    head = pos = p2;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    pos -&gt; next = p2;</span><br><span class=\"line\">                    pos = pos -&gt; next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p2 = p2 -&gt; next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1 != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                head = pos = p1;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                pos -&gt; next = p1;</span><br><span class=\"line\">                pos = pos -&gt; next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p1 = p1 -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p2 != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                head = pos = p2;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                pos -&gt; next = p2;</span><br><span class=\"line\">                pos = pos -&gt; next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p2 = p2 -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/\">剑指 Offer 52. 两个链表的第一个公共节点</a></p>\n<p> 【题解】</p>\n<p> 扫一遍A，为每个节点记录前驱。再扫一遍B，当一个节点已经存在前驱时，则为公共节点，取第一个公共节点为答案。新建一个root作为head的前驱</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headA == headB) <span class=\"keyword\">return</span> headA;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headA == <span class=\"literal\">NULL</span> || headB == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        map&lt;ListNode*, ListNode*&gt; fr;</span><br><span class=\"line\">        ListNode *root = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>();</span><br><span class=\"line\">        root -&gt; next = headA;</span><br><span class=\"line\">        ListNode *pos = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pos -&gt; next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fr[pos -&gt; next] = pos;</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pos = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pos != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fr.<span class=\"built_in\">find</span>(pos) != fr.<span class=\"built_in\">end</span>()) <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p> <strong>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存</strong></p>\n<p> O(1)内存意味着不能存和节点相关的数据，考虑用某种不用存储的方式判断公共。</p>\n<p> 由于链表特性，A,B一旦相交，其后所有节点均共有，所以A,B长度的区别可以视为不相交部分的区别，将较长链表的前部分节点跳过直至A,B剩余节点个数相同。双指针同时遍历两条链，当指向相同节点时，即为第一个公共节点</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getlen</span><span class=\"params\">(ListNode *pos)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pos != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            len++;</span><br><span class=\"line\">            pos = pos -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headA == headB) <span class=\"keyword\">return</span> headA;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(headA == <span class=\"literal\">NULL</span> || headB == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA = <span class=\"built_in\">getlen</span>(headA), lenB = <span class=\"built_in\">getlen</span>(headB);</span><br><span class=\"line\">        ListNode *posA = headA, *posB = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lenA &gt; lenB)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            posA = posA -&gt; next;</span><br><span class=\"line\">            lenA--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lenA &lt; lenB)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            posB = posB -&gt; next;</span><br><span class=\"line\">            lenB--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(posA != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(posA == posB) <span class=\"keyword\">return</span> posA;</span><br><span class=\"line\">            posA = posA -&gt; next;</span><br><span class=\"line\">            posB = posB -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"双指针（简单）-2\"><a href=\"#双指针（简单）-2\" class=\"headerlink\" title=\"双指针（简单）\"></a>双指针（简单）</h3><ol>\n<li><p><a href=\"https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></p>\n<p> 【题解】</p>\n<p> 双指针，跟快速排序思路差不多。注意判断i,j有没有过界</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">exchange</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; nums.<span class=\"built_in\">size</span>() &amp;&amp; nums[i] % <span class=\"number\">2</span> == <span class=\"number\">1</span>) i++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[j] % <span class=\"number\">2</span> == <span class=\"number\">0</span>) j--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= nums.<span class=\"built_in\">size</span>() || j &lt;= <span class=\"number\">0</span> || i &gt; j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[i], nums[j]);</span><br><span class=\"line\">            i++; j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/\">剑指 Offer 57. 和为s的两个数字</a></p>\n<p> 【题解】</p>\n<p> 枚举第一个数，二分第二个数</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> flag = <span class=\"built_in\">binary_search</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">begin</span>() + nums.<span class=\"built_in\">size</span>(), x);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;nums[i], x&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p> 写完发现自己傻了，二分查找O(logn)。直接标记出现的数，O(1)查找就行，总复杂度O(n)</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">bool</span>&gt; flag;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            flag[nums[i]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag.<span class=\"built_in\">find</span>(target - nums[i]) != flag.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;nums[i], target - nums[i]&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li></li>\n</ol>\n","categories":["历程"],"tags":["leetcode"]},{"title":"色彩模型","url":"/2022/04/11/%E7%AC%94%E8%AE%B0/%E8%89%B2%E5%BD%A9%E6%A8%A1%E5%9E%8B/","content":"<h1 id=\"色彩模型\"><a href=\"#色彩模型\" class=\"headerlink\" title=\"色彩模型\"></a>色彩模型</h1><h2 id=\"RGB模型\"><a href=\"#RGB模型\" class=\"headerlink\" title=\"RGB模型\"></a>RGB模型</h2><ul>\n<li>R（红）、G（绿）、B（蓝）</li>\n<li><strong>相加混色</strong>：主要应用于光学显示系统</li>\n<li><p>不符合人对色彩的主观理解</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204191100191.png\" width=\"350\"></p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204191106393.png\" width=\"300\"></p>\n</li>\n</ul>\n<h2 id=\"HSI模型\"><a href=\"#HSI模型\" class=\"headerlink\" title=\"HSI模型\"></a>HSI模型</h2><ul>\n<li><p>色调H（Hue）：与光波的波长有关，它表示人的感官对不同颜色的感受</p>\n<p>  <strong>色调取值是环状的（最大值=最小值）</strong></p>\n</li>\n<li><p>饱和度S（Saturation）：表示颜色的纯度。<strong>饱和度越大，颜色就越鲜艳</strong>，反之亦然</p>\n</li>\n<li><p>强度I（Intensity）：对应成像亮度和图像灰度，是颜色的明亮程度</p>\n<p>  HSI模型的色调、亮度、饱和度相互独立，对光照变化更鲁棒</p>\n</li>\n<li><p>符合人对色彩的主观理解</p>\n</li>\n</ul>\n<h2 id=\"RGB到HSI模型转换\"><a href=\"#RGB到HSI模型转换\" class=\"headerlink\" title=\"RGB到HSI模型转换\"></a>RGB到HSI模型转换</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204231908312.png\" width=\"550\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204232000425.png\" width=\"550\"></p>\n<ul>\n<li><p>若将RGB三通道立方体转换为H/S/I三个单通道立方体</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204232003493.png\" width=\"550\"></p>\n</li>\n<li><p>RGB三圆模型转换为HSI三通道</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204232008801.png\" width=\"550\"></p>\n</li>\n<li><p>HSI三圆模型转换为RGB三通道</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204232019235.png\" width=\"400\"></p>\n</li>\n</ul>\n<h1 id=\"图像压缩的色彩模型-YCbCr-YUV\"><a href=\"#图像压缩的色彩模型-YCbCr-YUV\" class=\"headerlink\" title=\"图像压缩的色彩模型 YCbCr/YUV\"></a>图像压缩的色彩模型 YCbCr/YUV</h1><p>YCbCr是用于彩色图像压缩时的一种表色系统。Y代表亮度，Cb、Cr代表色差。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204232046983.png\" width=\"450\"></p>\n<p>YCbCr主要采样格式有4:4:4, 4:2:2, 4:1:1, 4:2:0</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205100948094.png\" width=\"500\"></p>\n<p>采样依据：<strong>人类视觉系统对亮度比彩色敏感</strong></p>\n","categories":["笔记"],"tags":["RGB","HSI","YCbCr"]},{"title":"多媒体技术","url":"/2022/04/11/%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/","content":"<h1 id=\"多媒体技术的基本概念\"><a href=\"#多媒体技术的基本概念\" class=\"headerlink\" title=\"多媒体技术的基本概念\"></a>多媒体技术的基本概念</h1><h2 id=\"媒体的概念\"><a href=\"#媒体的概念\" class=\"headerlink\" title=\"媒体的概念\"></a>媒体的概念</h2><p>媒体（media）一词来源于拉丁语“Medius”，意为两者之间。媒体是传播信息的媒介。</p>\n<p>在计算机领域中，媒体有两种含义，一是<strong>信息的载体</strong>，如磁带、磁盘、光盘和半导体存储器，一是指<strong>载体的信息</strong>，如文字、声音、图形和图像。</p>\n<ol>\n<li><p>媒体的五种形式</p>\n<ul>\n<li><p>感知媒体：人们能直接获取信息的感觉形式，如视觉、听觉和触觉等</p>\n</li>\n<li><p>表示媒体：信息的表现形式，如图像、声音、视频、运动模式等</p>\n</li>\n<li><p>表现媒体：表现和获取信息的物理设备。如摄像机、话筒、显示器等</p>\n</li>\n<li><p>存储媒体：存储数据的物理设备，如磁盘、光盘、和半导体存储器等</p>\n</li>\n<li><p>传输媒体：传输数据的物理设备，如光纤等</p>\n</li>\n</ul>\n</li>\n<li><p>人类感知信息的途径</p>\n<p> 视觉（65%），听觉（20%），嗅觉、味觉、触觉（15%）</p>\n</li>\n<li><p>媒体分类</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205271539336.png\" width=\"370\"></p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205271541038.png\" width=\"280\"></p>\n</li>\n</ol>\n<h2 id=\"多媒体\"><a href=\"#多媒体\" class=\"headerlink\" title=\"多媒体\"></a>多媒体</h2><p>多媒体 = 多种媒体数据 + 一系列交互</p>\n<ul>\n<li>值：不同媒体形式的信息都是用“值”来表示。</li>\n<li>表现域：又称表现空间。媒体需要在一定的表现域中才能表现。可以是时间域，空间域，或时间-空间域。</li>\n<li>表现维：每一个表现空间有一个或多个的表现维。例如：图片（2维）</li>\n</ul>\n<p>值得注意的是，3D视频是四维的，比2D视频多出的维度是<strong>深度</strong></p>\n<h2 id=\"多媒体的数字化\"><a href=\"#多媒体的数字化\" class=\"headerlink\" title=\"多媒体的数字化\"></a>多媒体的数字化</h2><ol>\n<li><p>采样</p>\n<p> 采样也称取样，指把时间域或空间域的连续量转化成离散量的过程</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204112133773.png\" width=\"150\"></p>\n<p> 对图像而言，采样的实质就是要用多少点来描述一幅图像</p>\n<p> 采样造成的图片质量问题：边缘锯齿</p>\n</li>\n<li><p>量化</p>\n<p> 量化指将信号的连续取值近似为有限多个离散值的过程</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204112133159.png\" width=\"150\"></p>\n<p> 对图像而言，量化是指要使用多大范围的数值来表示图像采样之后的每一个点</p>\n<p> 量化造成的图片质量问题：假轮廓</p>\n</li>\n</ol>\n<h2 id=\"多媒体的主要特征\"><a href=\"#多媒体的主要特征\" class=\"headerlink\" title=\"多媒体的主要特征\"></a>多媒体的主要特征</h2><ol>\n<li><p>多维性</p>\n<p>多媒体技术的多维性指的是，它把计算机所能处理的信息媒体的种类或范围扩大。不仅局限于原来的数据、文本或单一的语音、图像等，还包括人类的视、听、嗅、味与触觉。</p>\n</li>\n<li><p>交互性</p>\n<p>交互可以做到自由的控制和干预信息的处理，增加对信息的注意力和理解，延长信息的保留时间。在计算机辅助教学、交互艺术等方面都取得了巨大的成功。</p>\n</li>\n<li><p>集成性</p>\n<p>多媒体的集成性主要表现在多媒体信息的集成和处理这些媒体的设备与设施的集成。多媒体系统是建立在一个大的信息环境之下，系统的各种设备与设施应该成为一个整体，以充分发挥多媒体特性的协同效应。</p>\n</li>\n<li><p>主观性</p>\n<p>多媒体信息通常是由人的感官来接受的，因此多媒体技术需要考虑人的生理和心理等主观特性，如人眼的<strong>视觉特性</strong>在视频技术中就得到广泛应用。</p>\n<blockquote>\n<ul>\n<li>视觉关注度</li>\n<li>几何错觉</li>\n<li>色彩错觉</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"多媒体技术的研究内容\"><a href=\"#多媒体技术的研究内容\" class=\"headerlink\" title=\"多媒体技术的研究内容\"></a>多媒体技术的研究内容</h1><h2 id=\"视频图像压缩\"><a href=\"#视频图像压缩\" class=\"headerlink\" title=\"视频图像压缩\"></a><a href=\"https://xyzinc-xyx.github.io/2022/05/28/%E7%AC%94%E8%AE%B0/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/\">视频图像压缩</a></h2><p>图像时静态的，只有一帧；视频是动态的，是由多帧连续图像组成的运动图像序列。（视觉暂留效应：帧率 &gt;= 25帧/秒）</p>\n<blockquote>\n<p>1G硬盘空间能存储多长时间未编码的720P高清电影？  </p>\n<p>1G = 1024 <em> 1024 </em> 1024 Byte<br>1s为编码720P电影 = 1280 <em> 720(p) </em> 1(s) <em> 3(色彩通道) </em> 25(帧) Byte<br>1G硬盘能存储<strong>约16秒</strong>未编码的720P高清电影<br>1G硬盘能存储<strong>约25分钟</strong>H.264编码的720P高清电影，压缩比约为<strong>100:1</strong>  </p>\n</blockquote>\n<p>视频压缩的本质是去冗余。</p>\n<h2 id=\"语音音频压缩\"><a href=\"#语音音频压缩\" class=\"headerlink\" title=\"语音音频压缩\"></a>语音音频压缩</h2><h2 id=\"多媒体通信与流媒体\"><a href=\"#多媒体通信与流媒体\" class=\"headerlink\" title=\"多媒体通信与流媒体\"></a>多媒体通信与流媒体</h2><h2 id=\"视频图像分析与检索\"><a href=\"#视频图像分析与检索\" class=\"headerlink\" title=\"视频图像分析与检索\"></a>视频图像分析与检索</h2>","categories":["笔记"],"tags":["多媒体"]},{"title":"C++STL常见容器","url":"/2022/03/28/C++STL/","content":"<span id=\"more\"></span>\n<h2 id=\"iterator-迭代器\"><a href=\"#iterator-迭代器\" class=\"headerlink\" title=\"iterator 迭代器\"></a>iterator 迭代器</h2><p>迭代器是一种检查容器内元素并遍历元素的数据类型</p>\n<ul>\n<li>声明方式：容器类型&lt;数据类型&gt;::iterator 名称；</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以vector为例</span></span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt;::iterator iter;</span><br><span class=\"line\"><span class=\"comment\">//遍历vector中的元素</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(iter = v.<span class=\"built_in\">begin</span>(); iter != v.<span class=\"built_in\">end</span>(); iter++)</span><br></pre></td></tr></table></figure>\n<h2 id=\"stack-栈\"><a href=\"#stack-栈\" class=\"headerlink\" title=\"stack 栈\"></a>stack 栈</h2><ul>\n<li><p>头文件：<code>#include &lt;stack&gt;</code></p>\n</li>\n<li><p>声明方式：stack&lt;类型&gt;名称;</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">stack&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">st.<span class=\"built_in\">empty</span>();          <span class=\"comment\">//判断栈是否为空</span></span><br><span class=\"line\">st.<span class=\"built_in\">size</span>();           <span class=\"comment\">//返回栈中元素的个数</span></span><br><span class=\"line\">st.<span class=\"built_in\">top</span>();            <span class=\"comment\">//返回栈顶元素, 但不删除该元素</span></span><br><span class=\"line\">st.<span class=\"built_in\">pop</span>();            <span class=\"comment\">//弹出栈顶元素, 但不返回其值</span></span><br><span class=\"line\">st.<span class=\"built_in\">push</span>();           <span class=\"comment\">//将元素压入栈顶</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"vector-动态数组\"><a href=\"#vector-动态数组\" class=\"headerlink\" title=\"vector 动态数组\"></a>vector 动态数组</h2><ul>\n<li><p>头文件：<code>#include &lt;vector&gt;</code></p>\n</li>\n<li><p>声明方式：vector&lt;类型&gt;名称;</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; v;</span><br><span class=\"line\">v.<span class=\"built_in\">emmpty</span>();         <span class=\"comment\">//判断数组是否为空</span></span><br><span class=\"line\">v.<span class=\"built_in\">size</span>();           <span class=\"comment\">//返回数组元素个数</span></span><br><span class=\"line\">v.<span class=\"built_in\">push_back</span>();      <span class=\"comment\">//在尾部增加元素</span></span><br><span class=\"line\">v.<span class=\"built_in\">pop_back</span>();       <span class=\"comment\">//将尾部元素删除</span></span><br><span class=\"line\">v.<span class=\"built_in\">clear</span>();          <span class=\"comment\">//清空数组</span></span><br><span class=\"line\">v.<span class=\"built_in\">begin</span>();          <span class=\"comment\">//返回第一个元素的迭代器（地址）</span></span><br><span class=\"line\">v.<span class=\"built_in\">end</span>();            <span class=\"comment\">//返回最后一个元素的迭代器（最后一个元素的下一个地址）</span></span><br><span class=\"line\">v.<span class=\"built_in\">erase</span>(l, r);      <span class=\"comment\">//删除地址[l, r)的所有元素，O(n)</span></span><br><span class=\"line\">v.<span class=\"built_in\">insert</span>(it, x);    <span class=\"comment\">//在迭代器it处插入元素x，O(n)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"queue-队列\"><a href=\"#queue-队列\" class=\"headerlink\" title=\"queue 队列\"></a>queue 队列</h2><ul>\n<li><p>头文件：<code>#include &lt;queue&gt;</code></p>\n</li>\n<li><p>声明方式：queue&lt;类型&gt;名称；</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">q.<span class=\"built_in\">empty</span>();          <span class=\"comment\">//判断队列是否为空</span></span><br><span class=\"line\">q.<span class=\"built_in\">size</span>();           <span class=\"comment\">//返回队列元素个数</span></span><br><span class=\"line\">q.<span class=\"built_in\">clear</span>();          <span class=\"comment\">//清空队列元素</span></span><br><span class=\"line\">q.<span class=\"built_in\">front</span>();          <span class=\"comment\">//返回队首元素</span></span><br><span class=\"line\">q.<span class=\"built_in\">back</span>();           <span class=\"comment\">//返回队尾元素</span></span><br><span class=\"line\">q.<span class=\"built_in\">push</span>();           <span class=\"comment\">//将元素插入队尾</span></span><br><span class=\"line\">q.<span class=\"built_in\">pop</span>();            <span class=\"comment\">//将队首元素删除</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.cnblogs.com/XYZinc/p/7356442.html\">优先队列 讲解及模板</a></p>\n<h2 id=\"map-映射\"><a href=\"#map-映射\" class=\"headerlink\" title=\"map 映射\"></a>map 映射</h2><ul>\n<li><p>头文件：<code>#include &lt;map&gt;</code></p>\n</li>\n<li><p>声明方式：map&lt;类型1, 映射后类型2&gt;名称;</p>\n</li>\n<li><p>map特性：<strong>map会按照键的顺序从小到大自动排序</strong></p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">map&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">mp[key] = val;      <span class=\"comment\">//赋值，若键key已存在映射，会覆盖</span></span><br><span class=\"line\">mp.<span class=\"built_in\">empty</span>();         <span class=\"comment\">//判断map是否为空</span></span><br><span class=\"line\">mp.<span class=\"built_in\">size</span>();          <span class=\"comment\">//返回映射的对数</span></span><br><span class=\"line\">mp.<span class=\"built_in\">begin</span>();         <span class=\"comment\">//返回第一个元素的迭代器（地址）</span></span><br><span class=\"line\">mp.<span class=\"built_in\">end</span>();           <span class=\"comment\">//返回map尾部的迭代器（最后一个元素的下一个地址）</span></span><br><span class=\"line\">mp.<span class=\"built_in\">find</span>(key);       <span class=\"comment\">//返回键key所在位置的迭代器，若map中不存在键key的映射，返回end()</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"set-集合\"><a href=\"#set-集合\" class=\"headerlink\" title=\"set 集合\"></a>set 集合</h2><ul>\n<li><p>头文件：<code>#include &lt;set&gt;</code></p>\n</li>\n<li><p>声明方式：set&lt;类型&gt;名称;</p>\n</li>\n<li><p>set特性：<strong>集合中的元素不重复，且从小大大自动排序</strong></p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">set&lt;<span class=\"keyword\">int</span>&gt; s;</span><br><span class=\"line\">s.<span class=\"built_in\">empty</span>();          <span class=\"comment\">//判断几何是否为空</span></span><br><span class=\"line\">s.<span class=\"built_in\">size</span>();           <span class=\"comment\">//返回集合中元素的个数</span></span><br><span class=\"line\">s.<span class=\"built_in\">clear</span>();          <span class=\"comment\">//清空集合</span></span><br><span class=\"line\">s.<span class=\"built_in\">insert</span>();         <span class=\"comment\">//插入元素，若集合中已存在该元素，不插入</span></span><br></pre></td></tr></table></figure>","categories":["语言"],"tags":["c++","STL"]},{"title":"计算机视觉相关笔记","url":"/2022/03/27/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%AC%94%E8%AE%B0/","content":"<blockquote>\n<p>笔记以jupyter书写，已上传至github仓库：<a href>还没传</a>，以下是导出的markdown版本，仅供参考，建议在jupyter中查看</p>\n</blockquote>\n<span id=\"more\"></span>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203281955120.png\" alt=\"计算机视觉概述\"></p>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><h2 id=\"1-Anaconda\"><a href=\"#1-Anaconda\" class=\"headerlink\" title=\"1. Anaconda\"></a>1. Anaconda</h2><p>Anaconda包含许多安装好的工具包。简单来说，它可以创造多个互不干涉的空间，在不同的空间内可以配置不同的环境，例如安装不同版本的软件进行使用。便于使用者在不同环境之间切换。</p>\n<p><a href=\"https://www.anaconda.com/products/individual#macos\">下载地址</a></p>\n<h2 id=\"2-CUDA-cuDNN\"><a href=\"#2-CUDA-cuDNN\" class=\"headerlink\" title=\"2.CUDA+cuDNN\"></a>2.CUDA+cuDNN</h2><p>和普通环境下安装步骤相同，不再赘述</p>\n<h2 id=\"3-tensorflow\"><a href=\"#3-tensorflow\" class=\"headerlink\" title=\"3.tensorflow\"></a>3.tensorflow</h2><p>运行Anaconda Prompt</p>\n<ol>\n<li><p>在Anaconda中创建tensorflow环境</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda create -n tensorflow python=3.9</span><br><span class=\"line\">按照自己的python版本修改</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>激活tensorflow</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">activate tensorflow</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>在激活tensorflow之前，Anaconda处于初始环境下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282007415.png\" width=\"350\"></p>\n<p>激活之后，切换至tensorflow环境下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282008514.png\" width=\"350\"></p>\n<ol>\n<li><p>在tensorflow环境下安装所需工具</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">opencv：pip install opencv-python</span><br><span class=\"line\">opencv辅助包：pip install opencv-contrib-python</span><br><span class=\"line\">jupyter: pip install jupyter</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<p>安装完毕后打开jupyter，测试是否安装成功</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"图像预处理\"><a href=\"#图像预处理\" class=\"headerlink\" title=\"图像预处理\"></a>图像预处理</h1><h2 id=\"图像显示与存储原理\"><a href=\"#图像显示与存储原理\" class=\"headerlink\" title=\"图像显示与存储原理\"></a>图像显示与存储原理</h2><h3 id=\"颜色空间\"><a href=\"#颜色空间\" class=\"headerlink\" title=\"颜色空间\"></a>颜色空间</h3><ol>\n<li><p>RGB颜色空间</p>\n<ul>\n<li><p>加法混色：彩色显示器</p>\n</li>\n<li><p>R, G, B三个通道</p>\n</li>\n<li><p>像素颜色值：(b, g, r)</p>\n</li>\n</ul>\n</li>\n<li><p>CMY(K)颜色空间</p>\n<ul>\n<li><p>减法混色：印刷</p>\n</li>\n<li><p>C（青）, M（品红）, Y（黄）颜色通道，Key通道</p>\n</li>\n<li><p>颜色像素值：(c, m, y, k)</p>\n</li>\n</ul>\n</li>\n<li><p>HSV颜色空间</p>\n<ul>\n<li><p>人类视觉概念：画家配色</p>\n</li>\n<li><p>H（色调）, S（饱和度）, V（明度）</p>\n</li>\n<li><p>颜色像素值：(h, s, v)</p>\n</li>\n</ul>\n</li>\n<li><p>CIE-XYZ颜色空间</p>\n<ul>\n<li><p>人类视觉系统：视锥细胞</p>\n<ul>\n<li>短波</li>\n<li>中波</li>\n<li>长波</li>\n</ul>\n</li>\n<li><p>三色<strong>刺激值</strong>通道：XYZ约略对应于红，绿，蓝</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"图像处理\"><a href=\"#图像处理\" class=\"headerlink\" title=\"图像处理\"></a>图像处理</h2><h3 id=\"图像处理-增强的目标\"><a href=\"#图像处理-增强的目标\" class=\"headerlink\" title=\"图像处理/增强的目标\"></a>图像处理/增强的目标</h3><p>图像预处理主要过程为图像增强，具体包括：图像锐化、平滑、去噪、灰度调整（对比度增强）等。</p>\n<p>目的简单来说是为了抑制无用信息，提高图像的使用价值</p>\n<h3 id=\"图像处理方法\"><a href=\"#图像处理方法\" class=\"headerlink\" title=\"图像处理方法\"></a>图像处理方法</h3><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282049578.png\" width=\"600\"></p>\n<h3 id=\"空间域处理\"><a href=\"#空间域处理\" class=\"headerlink\" title=\"空间域处理\"></a>空间域处理</h3><h4 id=\"点运算：基于直方图的对比度增强\"><a href=\"#点运算：基于直方图的对比度增强\" class=\"headerlink\" title=\"点运算：基于直方图的对比度增强\"></a>点运算：基于直方图的对比度增强</h4><p><strong>直方图</strong></p>\n<p>对图片数据/特征分布的一种统计，可以对数据空间进行量化</p>\n<ol>\n<li><p>直方图均衡化</p>\n<p> 直方图均衡化是指利用图像直方图对比度进行调整的方法，目的是为了调整图像的亮度。 </p>\n<p> 直方图均衡化本质上是对直方图进行非线性拉伸。重新分配各个灰度单位中的像素点数量，使一定灰度范围像素点数量的值大致相等。</p>\n</li>\n<li><p>自适应直方图均衡（AHE）</p>\n<p> 经典的直方图均衡算法只能调整画面整体亮度，对于有明显亮或暗区域的图像作用有限。</p>\n<p> 自适应直方图均衡算法（AHE）通过计算图像的局部直方图，然后重新分布亮度来来改变图像对比度。因此，该算法更适合于改进图像的局部对比度以及获得更多的图像细节。</p>\n<ul>\n<li><p>移动模板在图像上按固定长度移动，每次移动后在区域内做直方图均衡</p>\n</li>\n<li><p>图像中每个点会有多次的赋值，最终取值为这些赋值的均值</p>\n</li>\n</ul>\n</li>\n<li><p>限制对比度自适应直方图均衡（CLAHE）</p>\n<p> AHE算法会放大原本均匀区域的噪声</p>\n<p> CLAHE基于AHE算法进行了一些调整，如下图所示，将超出一定值的部分均分给所有点，使直方图整体变高</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282115075.png\" width=\"600\"></p>\n<p> 算法过程：</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282121728.png\" width=\"600\"></p>\n<p> 为避免块间颜色不连续，只有黑色部分为计算的均值，其余部分皆为差值结果</p>\n</li>\n</ol>\n<h4 id=\"形态学运算\"><a href=\"#形态学运算\" class=\"headerlink\" title=\"形态学运算\"></a>形态学运算</h4><ul>\n<li><p>膨胀：高亮部分扩张</p>\n</li>\n<li><p>腐蚀：高亮部分缩小</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282150142.png\" width=\"400\"></p>\n</li>\n<li><p>开运算：先腐蚀再膨胀， 可以去掉目标外的孤立点</p>\n</li>\n<li><p>闭运算：先膨胀再腐蚀， 可以去掉目标内的孔洞</p>\n</li>\n</ul>\n<h4 id=\"邻域运算\"><a href=\"#邻域运算\" class=\"headerlink\" title=\"邻域运算\"></a>邻域运算</h4><ol>\n<li><p>滤波/卷积</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282158419.png\" width=\"500\"></p>\n<p> 显然，卷积后的图像会变小。若想获得原图像尺寸的输出，则需要进行<strong>边界填充</strong>。获得同尺寸输出的情况下，卷积核越大，补充越多<br> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282210385.jpg\" width=\"450\"></p>\n</li>\n<li><p>边界填充策略</p>\n<ul>\n<li><p>补零</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282215478.png\" width=\"250\"></p>\n</li>\n<li><p>边界复制</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202205101004433.png\" width=\"250\"></p>\n</li>\n<li><p>镜像</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282217391.png\" width=\"250\"></p>\n</li>\n<li><p>块复制</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203282217890.png\" width=\"250\"></p>\n</li>\n</ul>\n</li>\n<li><p>均值滤波</p>\n<ul>\n<li><p>平滑均值滤波/卷积</p>\n<p>  平滑均值滤波是将原图像与核卷积后，得到的新图任意一点的像素值，都是周围 $n\\times m$ 个像素值的均值</p>\n<p>  显然，领域算子全为 $\\frac{1}{n \\times m}$</p>\n<p>  均值滤波本身存在缺陷，既没有很好地去除噪声点，也破坏了图像的细节使其变得模糊</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203290913406.png\" width=\"650\"></p>\n</li>\n<li><p>平滑中值滤波/卷积</p>\n<p>  卷积域内的像素值从小到大排序，取中间值作为卷积输出</p>\n<p>  有效去除椒盐噪声</p>\n</li>\n<li><p>平滑高斯滤波/卷积</p>\n<p>  模拟人眼，关注中心区域，能有效取出高斯噪声</p>\n<p>  高斯滤波的重要两步为：找到高斯模板，再进行卷积</p>\n<p>  二维高斯分布如下：</p>\n<script type=\"math/tex; mode=display\">\n  G(x,y) = \\frac{1}{2 \\pi \\sigma^2}e ^{- \\frac{x^2 + y^2}{2 \\sigma ^2} }</script><p>  其中，$(x,y)$为点坐标，$\\sigma$是标准差（方差）</p>\n<p>  若想获得高斯滤波器模板，首先以模板中心位置为坐标原点进行采样，可以获取其他各个位置的坐标</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203290930458.png\" width=\"200\"></p>\n<p>  再将坐标带入高斯函数中，即得到模板的系数</p>\n<p>  例如，对于窗口大小为$(2k+1)\\times(sk+1)$的模板，计算公式为：</p>\n<script type=\"math/tex; mode=display\">\n  G_{i,j} = \\frac{1}{2 \\pi \\sigma^2}e ^{- \\frac{(i-k-1)^2 + （j-k-)^2}{2 \\sigma ^2} }</script><p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203290947862.png\" width=\"350\"></p>\n<p>  在高斯函数中，$\\sigma$的大小决定高斯函数的宽度。高斯滤波中，$\\sigma$则表示关注区域的大小。$\\sigma$越小，表示关注区域越集中</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203290950302.png\" width=\"300\"></p>\n</li>\n<li><p>梯度prewitt滤波</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203290955192.png\" width=\"400\"></p>\n</li>\n<li><p>梯度Sobel滤波</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203290956491.png\" width=\"400\"></p>\n</li>\n<li><p>梯度Laplacian滤波</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"频率域处理\"><a href=\"#频率域处理\" class=\"headerlink\" title=\"频率域处理\"></a>频率域处理</h3><ol>\n<li><p>高斯金字塔</p>\n<p> 直接降采样会损失信息，高斯滤波可以将图片平滑地变小</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203291002820.png\" width=\"550\"></p>\n</li>\n</ol>\n<pre><code>高斯金字塔本质上为信号的多尺度表示法\n</code></pre><ol>\n<li><p>拉普拉斯金字塔</p>\n<p> 高频细节信息在卷积和下采样中丢失，保留所有层所丢失的高频信息，用于图像恢复</p>\n</li>\n<li><p>傅里叶变换</p>\n<p> 一个信号可以由<strong>足够多</strong>个不同<strong>频率</strong>和<strong>幅值</strong>的<strong>正余弦波</strong>组成</p>\n</li>\n<li><p>频谱滤波</p>\n<p> 基于傅里叶变换的滤波：低通滤波 </p>\n</li>\n</ol>\n","categories":["笔记"],"tags":["cv"]},{"title":"YOLOv4-Tiny理解笔记","url":"/2022/03/25/%E7%AC%94%E8%AE%B0/YOLOv4-Tiny%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"主干特征提取网络Backbone\"><a href=\"#主干特征提取网络Backbone\" class=\"headerlink\" title=\"主干特征提取网络Backbone\"></a>主干特征提取网络Backbone</h1><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204220939572.png\" alt=\"主干特征提取网络Backbone\"></p>\n<h1 id=\"CSPdarknet53-tiny的两大特点\"><a href=\"#CSPdarknet53-tiny的两大特点\" class=\"headerlink\" title=\"CSPdarknet53_tiny的两大特点\"></a>CSPdarknet53_tiny的两大特点</h1><ol>\n<li><p>使用了CSPnet结构<br><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202204220941336.png\" alt=\"CSPnet\"></p>\n</li>\n<li><p>进行通道的分割</p>\n</li>\n</ol>\n<h1 id=\"Yolo-Head\"><a href=\"#Yolo-Head\" class=\"headerlink\" title=\"Yolo Head\"></a>Yolo Head</h1><p>本质是一个 $3<em>3$ 的卷积和一个1</em>1的卷积<br>$3<em>3$ 的卷积进行特征整合<br>$1</em>1$ 的卷积进行通道数调整</p>\n","categories":["笔记"],"tags":["yolo","机器学习"]},{"title":"OpenCV整理","url":"/2022/03/22/OpenCV%E6%95%B4%E7%90%86/","content":"<span id=\"more\"></span>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><blockquote>\n<p>python:使用python语言编写，需要先配置环境</p>\n<p>OpenCV:一个开源的计算机视觉库。</p>\n<p>任意一个python编译器，我用的PyCharm</p>\n</blockquote>\n<ol>\n<li><p><strong>python</strong><br> <a href=\"https://www.python.org/\">https://www.python.org/</a><br> Downloads直接下载</p>\n<p> 安装时勾选“Add Python to PATH”</p>\n</li>\n<li><p><strong>OpenCV</strong><br> win+r，窗口输入cmd</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">   *opencv: pip install opencv-python</span><br><span class=\"line\">*opencv: pip install opencv-contrib-python</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>PyCharm</strong><br> <a href=\"jetbrains.com/pycharm/\">jetbrains.com/pycharm/</a></p>\n</li>\n</ol>\n<h2 id=\"图像基本操作\"><a href=\"#图像基本操作\" class=\"headerlink\" title=\"图像基本操作\"></a>图像基本操作</h2><ol>\n<li><p><strong>读取图片</strong></p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入cv模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取图片</span></span><br><span class=\"line\"><span class=\"comment\"># opencv读取的图片为BGR格式</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&quot;test.png&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示图片</span></span><br><span class=\"line\"><span class=\"comment\"># imshow(&#x27;image&#x27;,img)创建一个窗口显示图像，image为窗口显示的名称，img为显示的图像</span></span><br><span class=\"line\">cv.imshow(<span class=\"string\">&quot;test.png&quot;</span>, img)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 等待，毫秒，0表示任意键终止</span></span><br><span class=\"line\">cv.waitKey(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 释放内存</span></span><br><span class=\"line\">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>灰度图像</strong></p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># cv.IMREAD_COLOR：彩色图像</span></span><br><span class=\"line\"><span class=\"comment\"># cv.IMREAD_GRAYSCALE：灰度图像   </span></span><br><span class=\"line\">gray_img = cv.imread(<span class=\"string\">&quot;test.png&quot;</span>, cv.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>保存图片</strong></p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">cv.imwrite(<span class=\"string\">&quot;gray_test.png&quot;</span>, gray_img)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>尺寸修改</strong></p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">resize_img = cv.resize(img, dsize=(<span class=\"number\">200</span>,<span class=\"number\">200</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>绘制图形</strong></p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 绘制矩形</span></span><br><span class=\"line\"><span class=\"comment\"># cv.rectangle(绘制的图像, (左上角坐标x, y,矩形的长宽w, h), 颜色BGR，线条粗细)</span></span><br><span class=\"line\">cv.rectangle(img, (x, y, x+w, y+h), color=(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>), thickness=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># cv.rectangle(绘制的图像, pt1=(左上角坐标x,y), pt2=(右下角坐标x,y), 颜色，粗细)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 绘制圆形</span></span><br><span class=\"line\"><span class=\"comment\"># cv.circle(绘制的图像，(圆心坐标x, y), 半径, 颜色, 粗细)</span></span><br><span class=\"line\">cv.circle(img, center=(x, y), radius=<span class=\"number\">100</span>, color=(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>), thickness=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/人工智能实训项目复盘_绘制图形.png\" width=\"450\"></p>\n</li>\n<li><p><strong>读取视频</strong></p>\n</li>\n</ol>\n<ul>\n<li>cv.VideoCapture可以捕获摄像头，用数字来控制不同的设备</li>\n<li>如果是视频文件，直接指定路径即可  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 读入视频文件</span></span><br><span class=\"line\">vid = cv2.VideoCapture(<span class=\"string\">&quot;test.mp4&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    flag, frame = vid.read()</span><br><span class=\"line\">    <span class=\"comment\"># 读完退出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag == <span class=\"literal\">False</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    cv2.imshow(<span class=\"string\">&quot;frame&quot;</span>, frame) <span class=\"comment\"># 显示当前帧</span></span><br><span class=\"line\">    key = cv2.waitKey(<span class=\"number\">1000</span>//<span class=\"number\">24</span>) <span class=\"comment\"># 1s24帧</span></span><br><span class=\"line\">    <span class=\"comment\"># 按键退出</span></span><br><span class=\"line\">    <span class=\"comment\"># ord(&#x27;X&#x27;) 获取X的uniq码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> key == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">cv2.destroyAllWindows()</span><br><span class=\"line\">vid.release() <span class=\"comment\"># 释放视频流</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"图像、视频处理\"><a href=\"#图像、视频处理\" class=\"headerlink\" title=\"图像、视频处理\"></a>图像、视频处理</h2><ol>\n<li><p><strong>人脸识别</strong></p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 级联分类器</span></span><br><span class=\"line\"><span class=\"comment\"># 级联算法：图片中找人脸特征（研究，鼻子，嘴巴...），满足一部分特征，即算作人脸</span></span><br><span class=\"line\"><span class=\"comment\"># haarcascade_frontalface_alt.xml是OpenCV中一个训练好的人脸识别分类器</span></span><br><span class=\"line\">face_detector = cv2.CascadeClassifier(<span class=\"string\">&quot;haarcascade_frontalface_alt.xml&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检测人脸</span></span><br><span class=\"line\"><span class=\"comment\"># faces是一个坐标，左上角(x,y),宽w，高h</span></span><br><span class=\"line\"><span class=\"comment\"># detectMultiScale()是OpenCV人脸检测函数之一，可以通过使用不同的函数及调整参数，放宽或缩小检测的要求</span></span><br><span class=\"line\">faces = face_detector.detectMultiScale(img)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces: <span class=\"comment\"># 遍历faces</span></span><br><span class=\"line\">    <span class=\"comment\"># 绘制矩形</span></span><br><span class=\"line\">    cv2.rectangle(img, pt1=(x,y), pt2=(x+w, y+h), color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>), thickness=<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 绘制圆形</span></span><br><span class=\"line\">    cv2.circle(img, center=(x+w//<span class=\"number\">2</span>, y+h//<span class=\"number\">2</span>), radius=h//<span class=\"number\">2</span>, color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>), thickness=<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 显示文本</span></span><br><span class=\"line\">    cv2.putText(img,</span><br><span class=\"line\">            text = <span class=\"string\">&quot;yr&quot;</span>, <span class=\"comment\">#显示文本</span></span><br><span class=\"line\">            org = (x,y), <span class=\"comment\">#位置</span></span><br><span class=\"line\">            fontFace = cv2.FONT_ITALIC, <span class=\"comment\">#字体</span></span><br><span class=\"line\">            fontScale = <span class=\"number\">2</span>, <span class=\"comment\">#字号</span></span><br><span class=\"line\">            color = (<span class=\"number\">0.0</span>,<span class=\"number\">255</span>),</span><br><span class=\"line\">            thickness = <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231429053.png\" width=\"400\"></p>\n<p> 人脸识别中通常使用灰度图像，保留人脸特征，数据量减小</p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">gray_img = cv2.cvtColor(img, code=cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">face_detector = cv2.CascadeClassifier(<span class=\"string\">&quot;haarcascade_frontalface_alt.xml&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 使用灰度图像检测</span></span><br><span class=\"line\">faces = face_detector.detectMultiScale(gray_img)</span><br><span class=\"line\"><span class=\"comment\"># 绘制时使用彩色图像</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">    cv2.rectangle(img, pt1=(x,y), pt2=(x+w, y+h), color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>), thickness=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>多张人脸识别</strong></p>\n<p> 与单张人脸识别代码相同，for循环遍历所有人脸数据</p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">img = cv2.imread(<span class=\"string\">&quot;test2.jpg&quot;</span>)</span><br><span class=\"line\">gray_img = cv2.cvtColor(img, code=cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\"></span><br><span class=\"line\">face_detector = cv2.CascadeClassifier(<span class=\"string\">&quot;haarcascade_frontalface_alt.xml&quot;</span>)</span><br><span class=\"line\">faces = face_detector.detectMultiScale(gray_img)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">    cv2.rectangle(img, pt1=(x,y), pt2=(x+w,y+h), color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>), thickness=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">cv2.imshow(<span class=\"string\">&quot;faces&quot;</span>, img)</span><br><span class=\"line\">cv2.waitKey(<span class=\"number\">0</span>)</span><br><span class=\"line\">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231511049.png\" width=\"700\"></p>\n<p> <strong>某些多人照片无法全部识别，可以通过调整参数更改识别条件</strong></p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231540746.png\" width=\"700\"></p>\n<ul>\n<li>scaleFactor<br>scaleFactor表示前后两次相继的扫描中，搜索窗口的缩放比例，默认为1.1，即每次搜索窗口依次扩大10%<br>该参数越大，缩放越大，越容易遗漏然连；参数越小，越细腻，越容易找到</li>\n<li>minNeighbors<br>minNeighbors表示构成检测目标的相邻矩形的最小个数，默认为3，即检测三次成功才算目标<br>该参数越大，检测条件越苛刻；参数越小，检测条件越宽松</li>\n<li><p>minSize/maxSize<br>minSize/maxSize分别表示检测时目标的最小/最大尺寸</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">faces = face_detector.detectMultiScale(gray_img, scaleFactor=<span class=\"number\">1.1</span>, minNeighbors=<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231542985.png\" width=\"700\"></p>\n<p><strong>detectMultiScale2(), detectMultiScale3()使用方法类似，可自行查询</strong></p>\n</li>\n</ul>\n</li>\n<li><p><strong>图片马赛克</strong></p>\n<p> 先把人脸部分数据取出，隔几位保留一个，再放大回原大小</p>\n<ul>\n<li><p>cv2.resize()调整图片大小</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 抠出人脸</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">    <span class=\"comment\"># 图像：[高度, 宽度, 像素]</span></span><br><span class=\"line\">    face = img[y:y+h, x:x+w] <span class=\"comment\"># 只把人脸部分数据取出</span></span><br><span class=\"line\">    face = face[::<span class=\"number\">10</span>, ::<span class=\"number\">10</span>] <span class=\"comment\"># 每10个取1个</span></span><br><span class=\"line\">    face = cv2.resize(face, dsize = (w,h)) <span class=\"comment\"># 调整大小（缩放，模糊图像位置不准确）</span></span><br><span class=\"line\">    img[y:y + h, x:x + w] = face</span><br></pre></td></tr></table></figure>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231936774.png\" width=\"400\"></p>\n</li>\n<li><p>np.repeat()重复数据</p>\n<ul>\n<li>axis = 0, 沿y轴复制，增加行数</li>\n<li><p>axis = 1, 沿x轴复制，增加列数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">face = img[y:y+h, x:x+w]</span><br><span class=\"line\">face = face[::<span class=\"number\">10</span>, ::<span class=\"number\">10</span>]</span><br><span class=\"line\"><span class=\"comment\"># 两个方向重复</span></span><br><span class=\"line\">face = np.repeat(face, <span class=\"number\">10</span>, axis = <span class=\"number\">0</span>)</span><br><span class=\"line\">face = np.repeat(face, <span class=\"number\">10</span>, axis = <span class=\"number\">1</span>)</span><br><span class=\"line\">img[y:y+h, x:x+w] = face[:h, :w]</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231936809.png\" width=\"400\"></p>\n<p>对于多人图片，处理方法相同</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231940516.png\" width=\"700\">&lt;/img&gt;<br><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231941531.png\" width=\"700\"></p>\n</li>\n</ul>\n</li>\n<li><p>for循环直接替换</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">face = img[y:y+h, x:x+w]</span><br><span class=\"line\">face = face[::<span class=\"number\">10</span>, ::<span class=\"number\">10</span>] <span class=\"comment\"># 信息缺失的人脸</span></span><br><span class=\"line\"><span class=\"comment\"># for循环替换</span></span><br><span class=\"line\">h2, w2 = face.shape[:<span class=\"number\">2</span>] <span class=\"comment\"># 获取模糊人脸的宽、高</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(h2):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(w2):</span><br><span class=\"line\">        img[i*<span class=\"number\">10</span>+y:(i+<span class=\"number\">1</span>)*<span class=\"number\">10</span>+y, j*<span class=\"number\">10</span>+x:(j+<span class=\"number\">1</span>)*<span class=\"number\">10</span>+x] = face[i,j] <span class=\"comment\"># 一个像素一个像素进行替换，1个face数据替换10个img数据</span></span><br></pre></td></tr></table></figure>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203231952550.png\" width=\"400\"></p>\n</li>\n</ul>\n</li>\n<li><p><strong>替换</strong></p>\n<p> 和马赛克图片类似，将覆盖的内容改为想要替换的物体</p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">star = cv2.imread(<span class=\"string\">&quot;star.jpg&quot;</span>) <span class=\"comment\"># 读入要替换的图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">    star = cv2.resize(star, dsize=(w//<span class=\"number\">6</span>, h//<span class=\"number\">6</span>)) <span class=\"comment\"># 调整star的大小</span></span><br><span class=\"line\">    img[y:y+h//<span class=\"number\">6</span>, x+<span class=\"number\">5</span>*w//<span class=\"number\">12</span>: x+<span class=\"number\">5</span>*w//<span class=\"number\">12</span>+w//<span class=\"number\">6</span>] = star <span class=\"comment\"># 将star放在额头正中间</span></span><br></pre></td></tr></table></figure>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203232054814.png\" width=\"400\"></p>\n<p> 加入判断语句，可以不对周围白色进行赋值</p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(star)</span><br><span class=\"line\"><span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">star = cv2.resize(star, dsize=(w//<span class=\"number\">6</span>, h//<span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(h//<span class=\"number\">6</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(w//<span class=\"number\">6</span>):</span><br><span class=\"line\">        <span class=\"comment\"># if (star[i,j] == 255).all(): # 白色，不赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(star[i,j] &gt; <span class=\"number\">200</span>).<span class=\"built_in\">all</span>(): <span class=\"comment\"># 接近白色，不赋值</span></span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            img[i+y, j+x+<span class=\"number\">5</span>*w//<span class=\"number\">12</span>] = star[i,j]</span><br></pre></td></tr></table></figure>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203241057685.png\" width=\"400\"></p>\n</li>\n<li><p><strong>视频人脸识别</strong><br> 加入人脸识别后可以明显感觉出视频播放变慢，耗时操作为：扫描整张图片检测人脸<br> 即faces = face_detector.detecrMultiScale()</p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">vid = cv2.VideoCapture(<span class=\"string\">&quot;test4.mp4&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 使用分类器haarcascade_frontalface_alt.xml</span></span><br><span class=\"line\">face_detector = cv2.CascadeClassifier(<span class=\"string\">&quot;haarcascade_frontalface_alt.xml&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    flag, frame = vid.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag == <span class=\"literal\">False</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"comment\"># 将当前帧转换为灰度图像再进行检测</span></span><br><span class=\"line\">    gray_frame = cv2.cvtColor(frame, code = cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    faces = face_detector.detectMultiScale(gray_frame) <span class=\"comment\"># 主要耗时语句</span></span><br><span class=\"line\">    <span class=\"comment\"># 打印矩形</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">        cv2.rectangle(frame, pt1=(x,y), pt2=(x+w, y+h), color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>), thickness=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    cv2.imshow(<span class=\"string\">&quot;frame&quot;</span>, frame)</span><br><span class=\"line\">    key = cv2.waitKey(<span class=\"number\">1000</span>//<span class=\"number\">24</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 按键退出</span></span><br><span class=\"line\">    <span class=\"comment\"># ord(&#x27;X&#x27;) 获取X的uniq码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> key == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">cv2.destroyAllWindows()</span><br><span class=\"line\">vid.release() <span class=\"comment\"># 释放视频流</span></span><br></pre></td></tr></table></figure>\n<p> 通过缩小图片尺寸，可以加快检测时间</p>\n</li>\n<li><p><strong>视频保存</strong></p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将原视频文件转化为黑白，再进行保存</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"></span><br><span class=\"line\">vid = cv2.VideoCapture(<span class=\"string\">&quot;test4.mp4&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># cv2.VideoWriter(文件保存的路径, 指定编码器. 视频帧率, 画面尺寸, 黑白/彩色)</span></span><br><span class=\"line\"><span class=\"comment\"># *&#x27;MP4V&#x27;表示将‘MP4V’隔开，变成&#x27;M&#x27; &#x27;P&#x27; &#x27;4&#x27; &#x27;V&#x27;</span></span><br><span class=\"line\">writer = cv2.VideoWriter(filename = <span class=\"string\">&quot;gray_test.mp4&quot;</span>, fourcc = cv2.VideoWriter_fourcc(*<span class=\"string\">&#x27;MP4V&#x27;</span>), fps = <span class=\"number\">24</span>, frameSize = (<span class=\"number\">960</span>, <span class=\"number\">520</span>)) <span class=\"comment\"># 尺寸根据自己的视频进行修改</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    flag, frame = vid.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag == <span class=\"literal\">False</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    gray_frame = cv2.cvtColor(frame, code = cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    cv2.imshow(<span class=\"string\">&quot;frame&quot;</span>, gray_frame)</span><br><span class=\"line\">    writer.write(gray_frame) <span class=\"comment\"># 存入黑白图片</span></span><br><span class=\"line\">    key = cv2.waitKey(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> key == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">cv2.destroyAllWindows()</span><br><span class=\"line\">vid.release()</span><br><span class=\"line\">writer.release()</span><br></pre></td></tr></table></figure>\n<p> 按照以上代码执行，生成的gray_test.mp4文件无法打开，且检查属性会发现其大小大幅小于原视频大小。原因在于视频文件中对每一帧的存储应是[长，宽，颜色通道数]三维，而转换的灰度帧gray_frame只有二维，需要将其更改为三维再进行存储。</p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    flag, frame = vid.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag == <span class=\"literal\">False</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    gray_frame = cv2.cvtColor(frame, code = cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    gray_frame = np.reshape(gray_frame, [<span class=\"number\">520</span>, <span class=\"number\">960</span>, <span class=\"number\">1</span>]) <span class=\"comment\"># 增加一维</span></span><br><span class=\"line\">    gray_frame = np.repeat(gray_frame, <span class=\"number\">3</span>, axis=-<span class=\"number\">1</span>) <span class=\"comment\"># 颜色通道数增加为3，因为3个通道值一样，显示黑白</span></span><br><span class=\"line\">    cv2.imshow(<span class=\"string\">&quot;frame&quot;</span>, gray_frame)</span><br><span class=\"line\">    writer.write(gray_frame) <span class=\"comment\"># 存入三维黑白图片</span></span><br><span class=\"line\">    key = cv2.waitKey(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> key == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>摄像头操作</strong></p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 人脸识别</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"></span><br><span class=\"line\">vid = cv2.VideoCapture(<span class=\"number\">0</span>)</span><br><span class=\"line\">face_detector = cv2.CascadeClassifier(<span class=\"string\">&quot;haarcascade_frontalface_alt.xml&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    flag, frame = vid.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag == <span class=\"literal\">False</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    gray_frame = cv2.cvtColor(frame, code=cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    faces = face_detector.detectMultiScale(gray_frame)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">        cv2.rectangle(frame, pt1=(x,y), pt2=(x+w,y+h), color=(<span class=\"number\">0</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>), thickness=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    cv2.imshow(<span class=\"string\">&quot;frame&quot;</span>, frame)</span><br><span class=\"line\">    key = cv2.waitKey(<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> key == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">cv2.destroyAllWindows()</span><br><span class=\"line\">vid.release()</span><br></pre></td></tr></table></figure>\n<p> 替换，保存等均与视频处理相似</p>\n</li>\n</ol>\n<h2 id=\"人脸数据处理\"><a href=\"#人脸数据处理\" class=\"headerlink\" title=\"人脸数据处理\"></a>人脸数据处理</h2><ol>\n<li><p><strong>人脸采集</strong></p>\n<ul>\n<li>人脸检测：找到人脸，不需要分辨是谁</li>\n<li>人脸识别：判断这个人脸是谁，分辨，验证（比对相似特征，允许存在误差）<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"></span><br><span class=\"line\">cap = cv2.VideoCapture(<span class=\"number\">0</span>)</span><br><span class=\"line\">face_detector = cv2.CascadeClassifier(<span class=\"string\">&quot;haarcascade_frontalface_alt.xml&quot;</span>)</span><br><span class=\"line\">fileid = <span class=\"number\">1</span> <span class=\"comment\"># 记录存储图片的编号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    flag, frame = cap.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag == <span class=\"literal\">False</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    gray_frame = cv2.cvtColor(frame, code=cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    faces = face_detector.detectMultiScale(gray_frame)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x,y,w,h <span class=\"keyword\">in</span> faces:</span><br><span class=\"line\">        <span class=\"comment\"># 获取人脸，调整尺寸，保存</span></span><br><span class=\"line\">        face = gray_frame[y:y+h, x:x+w]</span><br><span class=\"line\">        face = cv2.resize(face, dsize=(<span class=\"number\">64</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">        cv2.imwrite(<span class=\"string\">&#x27;faces/name/%d.jpg&#x27;</span>%(fileid),face) <span class=\"comment\"># 文件夹好像得提前建好，没建的时候保存不下来</span></span><br><span class=\"line\">        fileid += <span class=\"number\">1</span></span><br><span class=\"line\">        cv2.rectangle(frame, pt1=(x, y), pt2=(x+w, y+h), color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>), thickness=<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> fileid &gt; <span class=\"number\">30</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    cv2.imshow(<span class=\"string\">&quot;face&quot;</span>, frame)</span><br><span class=\"line\">    cv2.waitKey(<span class=\"number\">1000</span>//<span class=\"number\">24</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">cv2.destroyAllWindows()</span><br><span class=\"line\">cap.release()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><strong>人脸识别</strong><br> 1) 首先将按照1采集到的人脸照片转化为numpy数组格式，以便后续处理</p>\n<pre><code> <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义了一个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load_data</span>():</span></span><br><span class=\"line\">    <span class=\"comment\"># os.listdir(path) 返回指定路径下的文件列表</span></span><br><span class=\"line\">    listdir = os.listdir(<span class=\"string\">&#x27;./faces&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># print(listdir) # 查看listdir</span></span><br><span class=\"line\">    names = [d <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> listdir]</span><br><span class=\"line\">    faces = [] <span class=\"comment\"># 记录图片信息</span></span><br><span class=\"line\">    target = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(names))]*<span class=\"number\">30</span> <span class=\"comment\"># 记录图片所属人物编号</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">dir</span> <span class=\"keyword\">in</span> names:  <span class=\"comment\"># 遍历所有人</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"number\">31</span>):</span><br><span class=\"line\">            img = cv2.imread(<span class=\"string\">&quot;./faces/%s/%d.jpg&quot;</span> % (<span class=\"built_in\">dir</span>, i))</span><br><span class=\"line\">            img_ = img[:, :, <span class=\"number\">0</span>]  <span class=\"comment\"># 取成二维数组</span></span><br><span class=\"line\">            cv2.imshow(<span class=\"string\">&quot;face&quot;</span>, img)</span><br><span class=\"line\">            faces.append(img_)  <span class=\"comment\"># 将目标文件添加到列表末尾</span></span><br><span class=\"line\">            <span class=\"comment\"># target.append(index) # 记录当前图片所属人物编号</span></span><br><span class=\"line\">    faces = np.asarray(faces)</span><br><span class=\"line\">    target = np.asarray(target)</span><br><span class=\"line\">    target.sort()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> faces, target, names</span><br></pre></td></tr></table></figure>\n</code></pre><p> 2) 将人脸数据分为两部分，用以训练和测试</p>\n<pre><code> <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">split_data</span>(<span class=\"params\">faces, target</span>):</span></span><br><span class=\"line\">    index = np.arange(<span class=\"number\">90</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 打乱数据</span></span><br><span class=\"line\">    np.random.shuffle(index)</span><br><span class=\"line\">    faces = faces[index]</span><br><span class=\"line\">    target = target[index]</span><br><span class=\"line\">    <span class=\"comment\"># 训练数据，测试数据</span></span><br><span class=\"line\">    X_train, X_test = face[:<span class=\"number\">70</span>], faces[<span class=\"number\">70</span>:]</span><br><span class=\"line\">    <span class=\"comment\"># 目标值，Y_test是X_test的真实值</span></span><br><span class=\"line\">    Y_train, Y_test = target[:<span class=\"number\">70</span>], target[<span class=\"number\">70</span>:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> X_train, X_test, Y_train, Y_test</span><br></pre></td></tr></table></figure>\n</code></pre><p> 完整代码如下：</p>\n <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load_data</span>():</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">split_data</span>(<span class=\"params\">faces, target</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 1.加载数据，返回目标值</span></span><br><span class=\"line\">    faces, target, names = load_data()</span><br><span class=\"line\">    <span class=\"comment\"># 2.数据拆分</span></span><br><span class=\"line\">    X_train, X_test, Y_train, Y_test = split_data(faces, target)</span><br><span class=\"line\">    <span class=\"comment\"># 3.加载算法</span></span><br><span class=\"line\">    face_recognizer = cv2.face.EigenFaceRecognizer_create()</span><br><span class=\"line\">    <span class=\"comment\"># 4.训练</span></span><br><span class=\"line\">    face_recognizer.train(X_train, Y_train)</span><br><span class=\"line\">    <span class=\"comment\"># 5.使用算法进行预测</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> face <span class=\"keyword\">in</span> X_test:</span><br><span class=\"line\">        <span class=\"comment\"># 返回的预测值是编号，需要找到对应名字</span></span><br><span class=\"line\">        <span class=\"comment\"># face_recognizer.predict()返回值为(类别，置信度)，置信度表示差距，越小越好</span></span><br><span class=\"line\">        y_id, confidence = face_recognizer.predict(face)</span><br><span class=\"line\">        name = names[y_id]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(name)</span><br><span class=\"line\">        cv2.imshow(<span class=\"string\">&quot;face&quot;</span>, face)</span><br><span class=\"line\">        key = cv2.waitKey(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> key == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":["技能"],"tags":["OpenCV","人脸识别"]},{"title":"前缀和 & 差分","url":"/2022/03/19/%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/","content":"<h2 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h2><p>对于给定数组A，它的前缀和数组为S，S[n]指数组A前n个元素之和，公式表示为：</p>\n<script type=\"math/tex; mode=display\">\nS[n] = \\sum_{i=1}^n A[i]</script><p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。</p>\n<script type=\"math/tex; mode=display\">\n\\sum_{i=l}^r A[i] = S[r] - S[l -1]</script><p><strong>常见用法：</strong>  </p>\n<ul>\n<li><p>计算区间和</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LeetCode 303.区域和检索 - 数组不可变：</span></span><br><span class=\"line\"><span class=\"comment\">// https://leetcode-cn.com/problems/range-sum-query-immutable/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumArray</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum[<span class=\"number\">100005</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NumArray</span>(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sum, <span class=\"number\">0</span>, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(sum));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) sum[i + <span class=\"number\">1</span>] = sum[i] + nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumRange</span><span class=\"params\">(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum[right + <span class=\"number\">1</span>] - sum[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//力扣的代码格式不太习惯QAQ</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>和大于k的最短子区间</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LeetCode 209. 长度最小的子数组</span></span><br><span class=\"line\"><span class=\"comment\">// https://leetcode-cn.com/problems/minimum-size-subarray-sum/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum[<span class=\"number\">100005</span>];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"keyword\">int</span> target, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.<span class=\"built_in\">size</span>(), ans = <span class=\"number\">100005</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) sum[i + <span class=\"number\">1</span>] = sum[i] + nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= len; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(sum[i] - sum[j] &gt;= target &amp;&amp; j &lt;= i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans = <span class=\"built_in\">min</span>(ans, i - j);</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans == <span class=\"number\">100005</span>) ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p>和等于k的子区间个数</p>\n<p>  map记录所有的前缀和，依次枚举sum[i]，ans += map[sum[i] - k]</p>\n<p>  考虑到直接记录所有前缀和无法区分区间和为-k的情况，map不能预处理，只能一边判断一边新增。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LeetCode 560. 和为 K 的子数组</span></span><br><span class=\"line\"><span class=\"comment\">// https://leetcode-cn.com/problems/subarray-sum-equals-k/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum[<span class=\"number\">20005</span>];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.<span class=\"built_in\">size</span>(), ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) sum[i + <span class=\"number\">1</span>] = sum[i] + nums[i];</span><br><span class=\"line\">        mp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= len; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;::iterator iter = mp.<span class=\"built_in\">find</span>(sum[i] - k);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(iter != mp.<span class=\"built_in\">end</span>()) ans += mp[sum[i] - k];</span><br><span class=\"line\">            iter = mp.<span class=\"built_in\">find</span>(sum[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(iter != mp.<span class=\"built_in\">end</span>()) mp[sum[i]]++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> mp[sum[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"扩展：二维-多维前缀和\"><a href=\"#扩展：二维-多维前缀和\" class=\"headerlink\" title=\"扩展：二维/多维前缀和\"></a>扩展：二维/多维前缀和</h3><p>二维数组的前缀和为某一位元素左上角矩形内所有元素之和。</p>\n<div align=\"center\">\n\n<img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/前缀和1.png\">\n\n</div>\n\n<p>公式表示为：</p>\n<script type=\"math/tex; mode=display\">\nS[n][m] = \\sum_{i=1}^n\\sum_{j=1}^m A[i][j]</script><p><strong>常见用法：</strong> </p>\n<ul>\n<li><p>查询区间和</p>\n<p>  $S = S[r][j] - S[l - 1][j] - S[r][i - 1] + S[l - 1][i - 1]$</p>\n<p>  红色矩形部分为左上角矩形减去蓝、绿矩形，再加上蓝绿矩形重叠部分</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/前缀和2.png\" alt=\"二维前缀和查询\"></p>\n</li>\n</ul>\n<h1 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h1><p>差分思想与前缀和类似，它维护的是“相邻两个元素之差”</p>\n<p>对于给定数组A，它的差分数组即为B，B[i]表示A[i]与A[i-1]之差，公式表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\n& B[i] = A[i] - A[i - 1] \\\\\n& B[1] = A[1]\n\\end{align*}</script><p>换句话说，数组A是数组B的前缀和</p>\n<p>当需要对数组A的区间[l, r]加上一个常数c时，只需要对数组B执行：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\n& B[l] += c \\\\\n& B[r + 1] -= c\n\\end{align*}</script>","categories":["算法"],"tags":["前缀和","差分"]},{"title":"高精度运算","url":"/2022/03/17/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/","content":"<h1 id=\"数据读入\"><a href=\"#数据读入\" class=\"headerlink\" title=\"数据读入\"></a>数据读入</h1><p>使用字符串读入待处理的数，并按位存入数组中。<br>注意：运算时进位是从低位向高位处理，所以在数组中，低位存在最前，高位存在最后（例如数123在数组A[0]-A[2]为(3,2,1)），留出进位的空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//a为读入的字符串，A为存储的数组</span></span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s%s&quot;</span>, a, b);</span><br><span class=\"line\">la = <span class=\"built_in\">strlen</span>(a);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; la; i++) A[la - i] = a[i] - <span class=\"string\">&#x27;0&#x27;</span>;<span class=\"comment\">//倒着存</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"数据输出\"><a href=\"#数据输出\" class=\"headerlink\" title=\"数据输出\"></a>数据输出</h1><p>由于读入的数是倒着存的，所以输出也到倒着输出。</p>\n<h1 id=\"高精度加\"><a href=\"#高精度加\" class=\"headerlink\" title=\"高精度加\"></a>高精度加</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//已将读入的数a,b存于数组A,B中</span></span><br><span class=\"line\">len = <span class=\"built_in\">max</span>(la, lb);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= len; i++) A[i] += B[i];<span class=\"comment\">//先将两数直接加起来</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= len; i++)<span class=\"comment\">//从低位开始，模拟进位</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tA[i + <span class=\"number\">1</span>] += A[i] / <span class=\"number\">10</span>;</span><br><span class=\"line\">\tA[i] %= <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(A[len + <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>) len++;<span class=\"comment\">//更新和的长度</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"高精度减\"><a href=\"#高精度减\" class=\"headerlink\" title=\"高精度减\"></a>高精度减</h1><p>做高精度减法时，需要保证是大数减小数。如果被减数比减数小，则交换两数，并输出负号”-“。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//a为被减数，b为减数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(la &lt; lb || (la == lb &amp;&amp; <span class=\"built_in\">strcmp</span>(a, b) &lt; <span class=\"number\">0</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ta -&gt; B;</span><br><span class=\"line\">\tb -&gt; A;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;-&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ta -&gt; A;</span><br><span class=\"line\">\tb -&gt; B;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>strcmp()函数用于比较两个字符串并根据比较结果返回整数。基本形式为strcmp(str1,str2)，若str1=str2，则返回零；若str1<str2，则返回负数；若str1>str2，则返回正数。</str2，则返回负数；若str1></p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">len = la;<span class=\"comment\">//取大数的位数</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= len; i++)<span class=\"comment\">//从低位开始，模拟减法</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(A[i] &lt; B[i])<span class=\"comment\">//如果不够减，借位</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tA[i + <span class=\"number\">1</span>]--;</span><br><span class=\"line\">\t\tA[i] += <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tA[i] -= B[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(A[len] == <span class=\"number\">0</span> &amp;&amp; len &gt; <span class=\"number\">1</span>) len--;<span class=\"comment\">//更新差的长度</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"高精度乘\"><a href=\"#高精度乘\" class=\"headerlink\" title=\"高精度乘\"></a>高精度乘</h1><h2 id=\"高精度乘单精度\"><a href=\"#高精度乘单精度\" class=\"headerlink\" title=\"高精度乘单精度\"></a>高精度乘单精度</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= la; i++) A[i] *= b;<span class=\"comment\">//先将两数直接相乘</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= la; i++)<span class=\"comment\">//从低位开始，模拟进位</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tA[i + <span class=\"number\">1</span>] += A[i] / <span class=\"number\">10</span>;</span><br><span class=\"line\">\tA[i] %= <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(A[la + <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>)<span class=\"comment\">//更新积的长度</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlen++;</span><br><span class=\"line\">\tA[la + <span class=\"number\">1</span>] += A[la] / <span class=\"number\">10</span>;</span><br><span class=\"line\">\tA[la] %= <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"高精度乘高精度\"><a href=\"#高精度乘高精度\" class=\"headerlink\" title=\"高精度乘高精度\"></a>高精度乘高精度</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">len = la + la;<span class=\"comment\">//两数之积的长度不会超过两数长度的和</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= la; i++)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= lb; j++)</span><br><span class=\"line\">\t\tC[i + j - <span class=\"number\">1</span>] += A[i] * B[j];</span><br><span class=\"line\"><span class=\"comment\">//x[i]:xi*10^(i-1)  y[j]:yj*10^(j-1)  z[i+j-1]:xi*yi*10^(i+j-2)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i= <span class=\"number\">1</span>; i &lt;= len; i++)<span class=\"comment\">//进位</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tC[i + <span class=\"number\">1</span>] += C[i] / <span class=\"number\">10</span>;</span><br><span class=\"line\">\tC[i] %= <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(C[len] == <span class=\"number\">0</span> &amp;&amp; len &gt; <span class=\"number\">1</span>) len--;<span class=\"comment\">//更新长度</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"高精度除\"><a href=\"#高精度除\" class=\"headerlink\" title=\"高精度除\"></a>高精度除</h1><p>除法运算是从高位开始往低位进行，所以当只需要进行除法运算时，可以顺序存入数组。如果多种运算都有，还是倒着存，倒着处理。</p>\n<p>以下代码展示倒序存储时的处理。</p>\n<h2 id=\"高精度除单精度\"><a href=\"#高精度除单精度\" class=\"headerlink\" title=\"高精度除单精度\"></a>高精度除单精度</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">d = <span class=\"number\">0</span>;<span class=\"comment\">//记录余数</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = len; i &gt;= <span class=\"number\">1</span>; i--)<span class=\"comment\">//从高位开始，模拟除法</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\td = d * <span class=\"number\">10</span> + A[i];</span><br><span class=\"line\">\tC[i] += d / b;</span><br><span class=\"line\">\td %= b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(C[len] == <span class=\"number\">0</span> &amp;&amp; len &gt; <span class=\"number\">1</span>) len--;<span class=\"comment\">//更新商的长度</span></span><br></pre></td></tr></table></figure>\n","categories":["算法"],"tags":["高精度"]},{"title":"排序","url":"/2022/03/16/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","content":"<p>排序根据实现方法可以分成比较类排序和非比较类排序两种。</p>\n<blockquote>\n<p>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p>\n<p>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p>\n</blockquote>\n<hr>\n<h2 id=\"非比较类排序\"><a href=\"#非比较类排序\" class=\"headerlink\" title=\"非比较类排序\"></a>非比较类排序</h2><h3 id=\"1-计数排序\"><a href=\"#1-计数排序\" class=\"headerlink\" title=\"1. 计数排序\"></a>1. 计数排序</h3><ul>\n<li><p>计数排序是一种不基于比较的排序，它利用函数映射的关系，将数据有序地进行存放，然后依次枚举取出，得到的即为有序的序列。</p>\n</li>\n<li><p>仅适用于整数。</p>\n</li>\n</ul>\n<blockquote>\n<p>时间复杂度：O(m)</p>\n</blockquote>\n<h3 id=\"2-桶排\"><a href=\"#2-桶排\" class=\"headerlink\" title=\"2. 桶排\"></a>2. 桶排</h3><ul>\n<li><p>计数排序的改进版，每个桶表示一个区间，可以放多个数据，再对桶内的数据进行排序。</p>\n</li>\n<li><p>当数据能均匀放在每个桶时，速度最快；当所有数据在一个桶时，速度最慢。</p>\n</li>\n</ul>\n<h3 id=\"3-基数排序\"><a href=\"#3-基数排序\" class=\"headerlink\" title=\"3. 基数排序\"></a>3. 基数排序</h3><ul>\n<li>根据键值的每位数字来分配桶。</li>\n</ul>\n<hr>\n<h2 id=\"比较类排序\"><a href=\"#比较类排序\" class=\"headerlink\" title=\"比较类排序\"></a>比较类排序</h2><h3 id=\"4-冒泡排序\"><a href=\"#4-冒泡排序\" class=\"headerlink\" title=\"4. 冒泡排序\"></a>4. <strong>冒泡排序</strong></h3><ul>\n<li><p>重复走访待排序的序列，每次比较两个相邻的元素，如果顺序错误就将它们交换。当没有元素需要交换时，排序完成。</p>\n</li>\n<li><p>每遍历一次至少确定一个元素的位置，排序可能会提前结束。</p>\n</li>\n</ul>\n<blockquote>\n<p>时间复杂度：O(n<sup>2</sup>)；最优：顺序状态O(n)；最坏：逆序状态O(n<sup>2</sup>)</p>\n<p>优点：实现简单；空间复杂度O(1)；性能稳定</p>\n</blockquote>\n<h3 id=\"5-选择排序\"><a href=\"#5-选择排序\" class=\"headerlink\" title=\"5. 选择排序\"></a>5. 选择排序</h3><ul>\n<li><p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。</p>\n</li>\n<li><p>数据移动次数最多为n-1次</p>\n</li>\n</ul>\n<blockquote>\n<p>时间复杂度：任何情况O(n^2)</p>\n<p>优点：移动次数少；极其稳定</p>\n</blockquote>\n<h3 id=\"6-插入排序\"><a href=\"#6-插入排序\" class=\"headerlink\" title=\"6. 插入排序\"></a>6. 插入排序</h3><ul>\n<li><p>插入排序的算法描述是一种简单直观的排序算法。它的基本思想是将待排序的序列插入到已经排好序的有序序列中，直至整个序列有序为止。</p>\n</li>\n<li><p>初始时，可认为第一个元素已经有序；从第二个元素开始，在有序序列中逐一比较，找到合适的位置进行插入。重复处理无序部分，每完成一趟遍历，至少新增一位有序元素。</p>\n</li>\n</ul>\n<blockquote>\n<p>时间复杂度：O(n<sup>2</sup>)；最优：顺序状态O(n)；最坏：逆序状态O(n<sup>2</sup>)</p>\n<p>优点：稳定。<br>缺点：比较次数不确定。移动次数多（使用链表可减少移动次数）</p>\n</blockquote>\n<h3 id=\"7-二分排序插入排序的优化\"><a href=\"#7-二分排序插入排序的优化\" class=\"headerlink\" title=\"7. 二分排序插入排序的优化\"></a>7. 二分排序<sup><a href=\"#fn_插入排序的优化\" id=\"reffn_插入排序的优化\">插入排序的优化</a></sup></h3><ul>\n<li><p>在有序序列中查找位置时，使用二分查找。</p>\n</li>\n<li><p>减少了比较的次数，移动次数不变。</p>\n</li>\n</ul>\n<blockquote>\n<p>时间复杂度：O(nlogn)</p>\n</blockquote>\n<h3 id=\"8-归并排序\"><a href=\"#8-归并排序\" class=\"headerlink\" title=\"8. 归并排序\"></a>8. 归并排序</h3><p>归并排序是典型的<strong>分治</strong>排序。</p>\n<details>\n    <summary><b>分治</b></summary>\n\n    在计算机科学中，分治是一种十分重要思想。分治算法就是对一个问题“分而治之”，其步骤如下：\n\n    - 分：将一个复杂的问题分解成多个相似的子问题，缩小问题的规模\n\n    - 治：当规模足够小时，子问题可以简单地求解\n\n    - 合并：将所有子问题的解合并，得到的即为原问题的解\n</details>\n\n<ul>\n<li>将现有系列细分为多个子序列，先使每个子序列有序，再使子序列间有序，即进行合并。最终得到完全有序的序列。</li>\n</ul>\n<blockquote>\n<p>时间复杂度：O(nlogn)</p>\n<p>优点：稳定；性能较好且不受初始数据影响。<br>缺点：需要额外的内存空间。</p>\n</blockquote>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergesort</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">mergesort</span>(l, mid);<span class=\"comment\">//分别对左右两部分进行归并排序</span></span><br><span class=\"line\">    <span class=\"built_in\">mergesort</span>(mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = l, j = mid + <span class=\"number\">1</span>, k = l;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= mid &amp;&amp; j &lt;= r &amp;&amp; k &lt;= r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i] &lt;= a[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            t[k++] = a[i++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> t[k++] = a[j++];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= mid) t[k++] = a[i++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &lt;= r) t[k++] = a[j++];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = l; i &lt;= r; i++) a[i] = t[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-快速排序\"><a href=\"#9-快速排序\" class=\"headerlink\" title=\"9. 快速排序\"></a>9. 快速排序</h3><p>快速排序是典型的分治排序，因其不需要额外存储空间且效率较高，成为最常用的排序算法。</p>\n<ul>\n<li>快速排序将待排序序列按关键字的大小分为两部分单独处理，再对这两部分继续进行快速排序，直至整个序列有序。</li>\n</ul>\n<blockquote>\n<p>时间复杂度O(nlogn);<br>最优：选取关键字将序列均分O(nlogn);<br>最坏：关键字取最大/小O(n<sup>2</sup>)</p>\n<p>缺点：不稳定。</p>\n</blockquote>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = a[<span class=\"built_in\">rand</span>()%(r-l)+l], i = l, j = r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(a[i] &lt; mid) i++;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(a[j] &gt; mid) j--;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i &lt;= j)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(a[i], a[j]);</span><br><span class=\"line\">        i++; j--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt; j) <span class=\"built_in\">quicksort</span>(l, j);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; r) <span class=\"built_in\">quicksort</span>(i, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"10-堆排序\"><a href=\"#10-堆排序\" class=\"headerlink\" title=\"10. 堆排序\"></a>10. 堆排序</h3><hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/1182974-20220316151115249-1364466307.png\" alt=\"复杂度总结\"></p>\n","categories":["算法"],"tags":["排序"]},{"title":"ACM基础知识框架(待整理)","url":"/2022/03/15/%E7%AE%97%E6%B3%95/ACM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%88%E5%BE%85%E6%95%B4%E7%90%86%EF%BC%89/","content":"<blockquote>\n<p>本博客写于ACM退役后准备实习期间，旨在梳理一下思路<del>（顺便填充一下博客）</del>，初学者可以参考知识点进行学习安排，但不建议按照文章顺序及使用文章中选取的题目进行对应训练。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/ACM.png\" alt=\"ACM知识框架\"></p>\n<h2 id=\"基础算法\"><a href=\"#基础算法\" class=\"headerlink\" title=\"基础算法\"></a>基础算法</h2><hr>\n<h3 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h3><p>模拟</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p><a href=\"https://xyzinc-xyx.github.io/2022/03/16/%E6%8E%92%E5%BA%8F/\">常见排序算法</a></p>\n<h3 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h3><p>一些题：<br><a href=\"https://www.cnblogs.com/XYZinc/p/7372898.html\">bzoj1150 [APIO2007]数据备份</a><br><a href=\"https://www.cnblogs.com/XYZinc/p/7404442.html\">luogu1791 线段覆盖</a><br><a href=\"https://www.cnblogs.com/XYZinc/p/7593703.html\">luogu2625 豪华游轮</a><br><a href=\"https://www.cnblogs.com/XYZinc/p/8862632.html\">loj6035「雅礼集训 2017 Day4」洗衣服</a></p>\n<h3 id=\"高精度\"><a href=\"#高精度\" class=\"headerlink\" title=\"高精度\"></a>高精度</h3><p><a href=\"https://xyzinc-xyx.github.io/2022/03/17/%E9%AB%98%E7%B2%BE%E5%BA%A6/\">高精度运算</a></p>\n<h3 id=\"前缀和-amp-差分\"><a href=\"#前缀和-amp-差分\" class=\"headerlink\" title=\"前缀和&amp;差分\"></a>前缀和&amp;差分</h3><p><a href=\"https://xyzinc-xyx.github.io/2022/03/19/%E5%89%8D%E7%BC%80%E5%92%8C&amp;%E5%B7%AE%E5%88%86/\">前缀和 &amp; 差分</a></p>\n<h3 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h3><h3 id=\"三分\"><a href=\"#三分\" class=\"headerlink\" title=\"三分\"></a>三分</h3><h3 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h3><h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><p>计算几何<br>    凸包<br>    半平面交<br>    旋转卡壳<br>    圆相关<br>    扫描线</p>\n<p>图论<br>    搜索<br>        BFS<br>        DFS<br>        A*<br>        迭代加深<br>        记忆化<br>    最短路<br>        Dijkstra<br>        Flody<br>        SPFA<br>        差分约束<br>        k短路<br>    树<br>        前/中/后序遍历<br>        树的直径<br>        最小生成树<br>            Kruskal<br>            Prim<br>            次小生成树<br>        最小度限制生成树<br>            k小度限制生成树<br>        哈夫曼树<br>    图的联通<br>        Tarjan<br>            强联通分量（有向图）<br>            双联通分量（无向图）<br>            割点<br>            割边（桥）<br>        2-SAT<br>    网络流<br>        最大流<br>        最小割<br>        费用流<br>            zkw<br>        Ford-Fulkerson<br>        Edmond-Karp<br>        Dinic<br>        待补充，具体参考网络流24题<br>    二分图<br>        二分图匹配<br>            匈牙利算法<br>            KM算法<br>        最小点覆盖<br>        最小边覆盖<br>        最大独立集<br>    并查集<br>        路径压缩<br>        带边权的并查集<br>        拆点<br>    欧拉回路<br>    拓扑排序</p>\n<p>数据结构<br>    基础数据结构<br>        栈<br>            单调栈<br>        队列<br>            单调队列<br>        堆<br>            可并堆<br>        链表<br>        哈希表<br>        倍增<br>    中级数据结构<br>        分块<br>        可并堆<br>            左偏树<br>            斜堆<br>            二项堆<br>        树状树组<br>        线段树<br>        平衡树<br>            splay<br>            treap<br>            替罪羊树<br>        数链剖分<br>    高级数据结构<br>        k-d tree<br>        主席树<br>        树套树<br>        LCT</p>\n<p>数论<br>    gcd及exgcd<br>    ksm<br>    线性筛<br>    高斯消元<br>    矩阵<br>        矩阵乘法<br>        矩阵快速幂<br>    乘法逆元<br>    组合数学<br>    欧拉函数<br>    中国剩余定理<br>    卢卡斯定理<br>    反素数<br>    置换<br>    莫比乌斯反演<br>    FFT快速傅里叶</p>\n<p>博弈论<br>    SG函数<br>    α-β</p>\n<p>模拟算法<br>    爬山算法<br>    模拟退火<br>    蚁群算法<br>    遗传算法</p>\n<p>字符串<br>    KMP<br>    Trie<br>    Hash<br>    AC自动机<br>    后缀树组<br>    Manacher</p>\n<p>动态规划<br>    背包<br>        01背包<br>        完全背包<br>        多重背包<br>        二维费用背包<br>        分组背包<br>        前k大背包<br>        有依赖的背包问题<br>        详情参考背包九讲<br>    LIS<br>    LCS<br>    区间dp<br>    树型dp<br>    状压dp<br>    双线dp</p>\n","categories":["历程"],"tags":["算法"]},{"title":"《机器学习》笔记","url":"/2022/03/12/%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"<blockquote>\n<p>网址：[吴恩达机器学习系列课程][<a href=\"https://www.bilibili.com/video/BV164411b7dx?p=5\">https://www.bilibili.com/video/BV164411b7dx?p=5</a>]</p>\n<p>推荐一个很全的笔记：<a href=\"https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes\">吴恩达机器学习教程中文笔记</a></p>\n</blockquote>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><blockquote>\n<p>Arthur Samuel(1959). Machine Learning: Field of study that gives computers the ability to learn without being explicitly programmed.</p>\n<p>Tom Mitchell(1998). Well-posed Learning Problem:A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</p>\n<blockquote>\n<p>计算机程序从经验E中学习，解决某一任务T，并进行某一性能度量P。通过P，测定程序在T上的表现因经验E而提高。</p>\n</blockquote>\n</blockquote>\n<p>常见的机器学习算法包括：监督学习和无监督学习。简单来说，监督学习指教会计算机做某件事，无监督学习则指让计算机自己学习。</p>\n<h2 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h2><p>监督学习指给算法一个数据集，其中包含了正确答案，算法的目的是对于位置数据能计算出更多的正确答案。</p>\n<h3 id=\"回归问题\"><a href=\"#回归问题\" class=\"headerlink\" title=\"回归问题\"></a>回归问题</h3><p>预测<strong>连续</strong>值的输出。例如对房价的预测</p>\n<h3 id=\"分类问题\"><a href=\"#分类问题\" class=\"headerlink\" title=\"分类问题\"></a>分类问题</h3><p>预测一个离散值的输出。例如对肿瘤恶性、良性的判断，用于对事物的分类</p>\n<h2 id=\"无监督学习\"><a href=\"#无监督学习\" class=\"headerlink\" title=\"无监督学习\"></a>无监督学习</h2><p>无监督学习的数据集没有标签或全部具有相同的标签，关于学习没有明确的目的，而是让算法自行寻找这些数据中的某种结构，将数据集划分为几个类别。</p>\n<h3 id=\"聚类算法\"><a href=\"#聚类算法\" class=\"headerlink\" title=\"聚类算法\"></a>聚类算法</h3><p>将数据集分成簇，使簇内相似性高，簇间相似性第。例如谷歌新闻的专题分类</p>\n<h1 id=\"单变量线性回归\"><a href=\"#单变量线性回归\" class=\"headerlink\" title=\"单变量线性回归\"></a>单变量线性回归</h1><h2 id=\"模型表示\"><a href=\"#模型表示\" class=\"headerlink\" title=\"模型表示\"></a>模型表示</h2><blockquote>\n<p>训练集（Training Set）：</p>\n<ul>\n<li>$m$ : 训练集中实例的数量  </li>\n<li>$x$ : 特征变量/输入变量</li>\n<li>$y$ : 目标变量/输出变量</li>\n<li>$(x,y)$ : 训练集中的样本</li>\n<li>$( { { x } ^ { (i) } }, { { y } ^ { (i) } } )$ 第$i$ 个训练样本</li>\n<li>$h$: 假设函数（hypothesis），代表学习算法的解决方案 </li>\n</ul>\n</blockquote>\n<p>对于单变量线性回归问题，预测函数的表达方式为：$h_\\theta \\left( x \\right)=\\theta_{0} + \\theta_{1}x$</p>\n<h2 id=\"代价函数\"><a href=\"#代价函数\" class=\"headerlink\" title=\"代价函数\"></a>代价函数</h2><p>在线性回归中，我们要解决的是一个最小化问题，即选择合适的参数（$\\theta_{0}$, $\\theta_{1}$），使得$h \\left( x \\right)$和$y$的差距（$(h \\left( x \\right) - y)^2$）尽量小</p>\n<p>我们使用代价函数来描述这个差距：</p>\n<script type=\"math/tex; mode=display\">\nJ \\left( \\theta_0, \\theta_1 \\right) = \\frac{1}{2m}\\sum\\limits_{i=1}^m \\left( h_{\\theta}(x^{(i)})-y^{(i)} \\right)^{2}</script><blockquote>\n<p>$\\frac{1}{2m}$中的2是为了后续求导时可以直接抵消，方便计算</p>\n</blockquote>\n<h2 id=\"代价函数的直观理解\"><a href=\"#代价函数的直观理解\" class=\"headerlink\" title=\"代价函数的直观理解\"></a>代价函数的直观理解</h2><blockquote>\n<ul>\n<li>假设函数：$h_\\theta \\left( x \\right)=\\theta_{0} + \\theta_{1}x$</li>\n<li>参数：$\\theta_{0}$, $\\theta_{1}$</li>\n<li>代价函数：$J \\left( \\theta_0, \\theta_1 \\right) = \\frac{1}{2m}\\sum\\limits_{i=1}^m \\left( h_{\\theta}(x^{(i)})-y^{(i)} \\right)^{2}$</li>\n<li>目标：$\\min_{\\theta_{0},\\theta_{1}}{J \\left( \\theta_0, \\theta_1 \\right) }$</li>\n</ul>\n</blockquote>\n<ol>\n<li><p>简化函数，令$\\theta_{0} = 0$</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261056417.png\" width=\"500\"></p>\n</li>\n<li><p>原函数</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261345095.png\" width=\"350\"></p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261345271.png\" width=\"550\"></p>\n</li>\n</ol>\n<h2 id=\"梯度下降\"><a href=\"#梯度下降\" class=\"headerlink\" title=\"梯度下降\"></a>梯度下降</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>梯度下降是一种寻找目标函数最小化的算法。</p>\n<p>开始时从某个点$(\\theta_{0}, \\theta_{1})$出发，寻找下降速度最快的方向前进，并重复寻找方向和移动，直到到达局部最低点。</p>\n<p>梯度下降的特点有：起点的微小移动可能就会导致完全不同的局部最优解。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261358354.jpg\" width=\"500\"></p>\n<h3 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h3><p>梯度下降的公式为：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261407833.png\" width=\"400\"></p>\n<blockquote>\n<ul>\n<li>$\\alpha$ : 学习率，用于控制梯度下降时每次前进的步子有多大。</li>\n</ul>\n</blockquote>\n<p>注意：计算梯度下降公式时，$\\theta_{0}, \\theta_{1}$需要同步更新</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261421665.png\" width=\"600\"></p>\n<h3 id=\"公式详解\"><a href=\"#公式详解\" class=\"headerlink\" title=\"公式详解\"></a>公式详解</h3><ol>\n<li><p>学习率$\\alpha$</p>\n<ul>\n<li><p>$\\alpha$太小，移动速度很慢<br><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261432038.png\" width=\"600\"></p>\n</li>\n<li><p>$\\alpha$太大，可能导致结果无法收敛甚至发散<br><img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261434218.png\" width=\"600\"></p>\n</li>\n</ul>\n</li>\n<li><p>导数（斜率）$\\frac{\\partial }{\\partial {\\theta_{j} } }J\\left(\\theta \\right)$</p>\n<p> 当$\\theta_{0}$越靠近最小值，斜率越小，即越接近局部最低点梯度下降算法会自动采取更小的幅度进行移动，当到达最低点时，斜率为0，不再移动。</p>\n<p> 所以没有必要另外减小$\\alpha$。</p>\n<p> <img src=\"https://cdn.jsdelivr.net/gh/XYZinc-xyx/XYZinc-Images@master/blog/202203261444930.png\" width=\"480\"></p>\n</li>\n</ol>\n<h2 id=\"应用于线性回归的梯度下降算法\"><a href=\"#应用于线性回归的梯度下降算法\" class=\"headerlink\" title=\"应用于线性回归的梯度下降算法\"></a>应用于线性回归的梯度下降算法</h2><script type=\"math/tex; mode=display\">\n\\frac{\\partial }{\\partial { {\\theta }_{j} } } J( { {\\theta }_{0} }, { { \\theta }_{1} } ) = \\frac{ \\partial }{\\partial { { \\theta }_{j} } }\\frac{1}{2m}{ { \\sum \\limits_{i=1}^{m} {\\left ( { {h}_{\\theta } } ( { {x}^{ (i) } } )-{ {y}^{(i)} } \\right) } }^{2}}</script><p>$j=0$  时：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial }{\\partial { {\\theta }_{0} } }J( { {\\theta }_{0} },{ {\\theta }_{1} } )=\\frac{1}{m}{ {\\sum\\limits_{i=1}^{m}{\\left( { {h}_{ \\theta } }( { {x}^{ (i) } } )-{ {y}^{ (i) } } \\right) } } }</script><p>$j=1$  时：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial }{\\partial { {\\theta }_{1} } }J( { {\\theta }_{0} },{ {\\theta }_{1} } )=\\frac{1}{m}\\sum\\limits_{i=1}^{m}{\\left( \\left( { {h}_{\\theta } }( { {x}^{ (i) } } )-{ {y}^{ (i) } } \\right)\\cdot { {x}^{ (i) } } \\right) }</script><h3 id=\"公式-1\"><a href=\"#公式-1\" class=\"headerlink\" title=\"公式\"></a>公式</h3><p><strong>Repeat {</strong></p>\n<p>​                ${ \\theta_{0} } := { \\theta_{0} } - a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{ \\left( { {h}_{\\theta } } ( { {x}^{ (i) } } )-{ {y}^{ (i) } } \\right) }$</p>\n<p>​                ${ \\theta_{1} } := { \\theta_{1} } - a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{\\left( \\left( { {h}_{\\theta } }( { {x}^{ (i) } } )-{ {y}^{ (i) } } \\right)\\cdot { {x}^{ (i) } } \\right) }$</p>\n<p>​               <strong>}</strong></p>\n<p>该算法又被称之为“Batch梯度下降（批量梯度下降”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本。</p>\n<p>实际上，还存在一些其他的梯度下降算法，不考虑整个的训练集，而是每次只关注训练集中的一些小的子集。</p>\n<h1 id=\"线性代数回顾\"><a href=\"#线性代数回顾\" class=\"headerlink\" title=\"线性代数回顾\"></a>线性代数回顾</h1><h2 id=\"矩阵和向量\"><a href=\"#矩阵和向量\" class=\"headerlink\" title=\"矩阵和向量\"></a>矩阵和向量</h2><ul>\n<li><p><strong>矩阵</strong>：由数字组成的矩形阵列</p>\n</li>\n<li><p><strong>矩阵的维数</strong>：$行数 \\times 列数$</p>\n</li>\n<li><p><strong>向量</strong>：向量是只有一列的矩阵，维数即向量的行数</p>\n</li>\n</ul>\n<h2 id=\"加法和标量乘法\"><a href=\"#加法和标量乘法\" class=\"headerlink\" title=\"加法和标量乘法\"></a>加法和标量乘法</h2><h2 id=\"矩阵向量乘法\"><a href=\"#矩阵向量乘法\" class=\"headerlink\" title=\"矩阵向量乘法\"></a>矩阵向量乘法</h2><h2 id=\"矩阵乘法\"><a href=\"#矩阵乘法\" class=\"headerlink\" title=\"矩阵乘法\"></a>矩阵乘法</h2><h2 id=\"矩阵乘法特征\"><a href=\"#矩阵乘法特征\" class=\"headerlink\" title=\"矩阵乘法特征\"></a>矩阵乘法特征</h2><h2 id=\"逆合转置\"><a href=\"#逆合转置\" class=\"headerlink\" title=\"逆合转置\"></a>逆合转置</h2>","categories":["笔记"],"tags":["机器学习"]},{"title":"hexo+github（自用）","url":"/2021/11/16/hexo+github/","content":"<ol>\n<li><p>git安装</p>\n<p> 检查：git —version</p>\n</li>\n<li><p>nodejs安装</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">下载安装</span><br><span class=\"line\">git bash</span><br><span class=\"line\">\tnpm install hexo -g （安装，-g表示全局）</span><br><span class=\"line\">\t初始化：hexo init</span><br><span class=\"line\">\t生成：hexo g</span><br><span class=\"line\">\t启动服务：hexo s</span><br><span class=\"line\">\t\t（根据提示打开网站）</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">新建完成后，文件夹目录如下：</span><br><span class=\"line\">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds # 模版文件夹</span><br><span class=\"line\">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span><br><span class=\"line\">|   ├── _drafts # 草稿文件</span><br><span class=\"line\">|   └── _posts # 文章Markdowm文件 </span><br><span class=\"line\">└── themes  # 主题文件夹</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>hexo + github</p>\n<p> 1) 配置SSH key</p>\n<p> 提交代码到github需要权限，但直接使用用户名和密码不安全，所以使用SSH key解决本地和服务器连接问题</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd ~/. ssh # 检查本机已存在的ssh秘钥</span><br><span class=\"line\"># 若提示No such file or directory，说明是第一次使用，需配置Git的user name和email</span><br><span class=\"line\">$ git config --global user.name &quot;username&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 生成秘钥</span><br><span class=\"line\">$ ssh-keygen -t rsa -C &quot;email&quot;</span><br><span class=\"line\"># 三次回车，用户/.ssh路径下生成id_rsa和id_rsa.pub两个文件</span><br><span class=\"line\"># 将id_ras.pub内容复制至github -&gt; settings -&gt; ssh and gpg keys</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 测试是否成功</span><br><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\">/*</span><br><span class=\"line\">若失败</span><br><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\">The authenticity of host &#x27;github.com (52.74.223.119)&#x27; can&#x27;t be established.</span><br><span class=\"line\">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class=\"line\">Warning: Permanently added &#x27;github.com,52.74.223.119&#x27; (RSA) to the list of known hosts.</span><br><span class=\"line\">Hi XYZinc-xyx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class=\"line\">缺失known_hosts文件，输入yes自动生成</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p> 2) 配置Deployment</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">打开_config.yml文件，末尾添加：</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">type: git</span><br><span class=\"line\">repository: http://github.com/XYZinc-xyx/XYZinc-xyx.github.io.git</span><br><span class=\"line\">branch: master</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">type: git</span><br><span class=\"line\">repository: git@github.com:XYZinc-xyx/XYZinc-xyx.github.io.git</span><br><span class=\"line\">branch: main</span><br><span class=\"line\"># 首行缩进不能删除</span><br><span class=\"line\"># 第一种写法好像不能用了</span><br><span class=\"line\"># 注意分支</span><br></pre></td></tr></table></figure>\n<p> 3) 安装部署插件 hexo-deployer-git</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<p>到此为止hexo+github的连接已经完成，开始尝试将文章放在github上</p>\n<p>1) 新建博客<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new post &quot;article titlt&quot;</span><br><span class=\"line\">/*</span><br><span class=\"line\">---</span><br><span class=\"line\">    title: postName #文章页面上的显示名称，一般是中文</span><br><span class=\"line\">    date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class=\"line\">    categories: 默认分类 #分类</span><br><span class=\"line\">    tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class=\"line\">    description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class=\"line\">---</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<p>2) 生成、部署<br>    <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo g //generate 生成静态文件</span><br><span class=\"line\">$ hexo d //deploy 部署网站</span><br><span class=\"line\"></span><br><span class=\"line\"># 或者同时生成、部署</span><br><span class=\"line\">$ hexo g -d</span><br><span class=\"line\"></span><br><span class=\"line\">* 在部署前建议先执行 $ hexo clean，清除缓存文件(db.json)和已生成的静态文件(public)</span><br></pre></td></tr></table></figure></p>\n<p>3) 注意在GitHub Pages里，默认分支改成了main，所以_config.yml需要同步修改<br>    也可以新建仓库的时候直接对仓库进行修改</p>\n<hr>\n<p><strong>LaTex</strong>公式</p>\n<p>参考博客：</p>\n<p><a href=\"https://www.cnblogs.com/iHeling/p/14095986.html\">https://www.cnblogs.com/iHeling/p/14095986.html</a></p>\n<p><a href=\"https://blog.csdn.net/alexander_monster/article/details/105717091\">https://blog.csdn.net/alexander_monster/article/details/105717091</a></p>\n<ol>\n<li><p>更换Hexo渲染引擎</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改kramed语法解释</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 文件路径：/node_modules/kramed/lib/rules/inline.js</span><br><span class=\"line\"># 修改escape, strong, em</span><br><span class=\"line\"></span><br><span class=\"line\">escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,</span><br><span class=\"line\">strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,</span><br><span class=\"line\">em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>激活mathjax</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 文件路径：/themes/next/_config.yml</span><br><span class=\"line\"># MathJax false改成true</span><br><span class=\"line\"></span><br><span class=\"line\">mathjax:</span><br><span class=\"line\">enable: true</span><br><span class=\"line\"># See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class=\"line\">mhchem: true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在需要使用数学公式的文章的Front-matter里打开mathjax开关</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: 前缀和 &amp; 差分</span><br><span class=\"line\">tags: 前缀和; 差分</span><br><span class=\"line\">categories: 算法</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":["test"],"tags":["test"]},{"title":"测试","url":"/2021/11/15/test/","content":"<p>My first blog.</p>\n<p>可以到博客园逛逛旧博客：<a href=\"https://www.cnblogs.com/XYZinc/\">https://www.cnblogs.com/XYZinc/</a></p>\n","categories":["test"],"tags":["test"]}]